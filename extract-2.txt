# Brave Browser Password Extraction & Decryption Script
# Focused on Brave browser only for debugging

param(
    [string]$CSVPath = ".\BravePasswords.csv"
)

# Add required assemblies
Add-Type -AssemblyName System.Security
Add-Type -AssemblyName System.Core

# Function to check if SQLite3 is already available
function Test-SQLiteAvailable {
    try {
        $version = sqlite3 --version 2>$null
        if ($version -like "3.*") {
            Write-Host "SQLite3 is already available: $version" -ForegroundColor Green
            return $true
        }
    } catch {
        if (Test-Path ".\sqlite3.exe") {
            Write-Host "SQLite3 found in current directory" -ForegroundColor Green
            return $true
        }
    }
    return $false
}

# Function to install SQLite3 if needed
function Install-SQLiteIfNeeded {
    Write-Host "Downloading SQLite3..." -ForegroundColor Yellow
    try {
        $sqliteUrl = "https://www.sqlite.org/2023/sqlite-tools-win32-x86-3430200.zip"
        $tempZip = "sqlite-temp.zip"
        
        Invoke-WebRequest -Uri $sqliteUrl -OutFile $tempZip -UseBasicParsing
        Expand-Archive -Path $tempZip -DestinationPath ".\sqlite-temp" -Force
        Copy-Item ".\sqlite-temp\sqlite-tools-win32-x86-3430200\sqlite3.exe" ".\sqlite3.exe" -Force
        
        Remove-Item $tempZip -Force -ErrorAction SilentlyContinue
        Remove-Item ".\sqlite-temp" -Recurse -Force -ErrorAction SilentlyContinue
        
        Write-Host "SQLite3 downloaded successfully." -ForegroundColor Green
        return $true
    } catch {
        Write-Warning "Failed to download SQLite3: $($_.Exception.Message)"
        return $false
    }
}

# Function to decrypt data using Windows DPAPI
function Get-DecryptedData {
    param([byte[]]$EncryptedData)
    
    try {
        $decrypted = [System.Security.Cryptography.ProtectedData]::Unprotect(
            $EncryptedData, 
            $null, 
            [System.Security.Cryptography.DataProtectionScope]::CurrentUser
        )
        return [System.Text.Encoding]::UTF8.GetString($decrypted)
    } catch {
        Write-Host "DPAPI Decryption failed for data of length: $($EncryptedData.Length)" -ForegroundColor Yellow
        return $null
    }
}

# Function to extract master key from Brave's Local State file
function Get-BraveMasterKey {
    $braveDataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
    $localStatePath = Join-Path $braveDataPath "Local State"
    
    if (-not (Test-Path $localStatePath)) {
        Write-Host "Local State file not found at: $localStatePath" -ForegroundColor Red
        return $null
    }
    
    try {
        Write-Host "Reading Local State file..." -ForegroundColor Yellow
        $localStateContent = Get-Content $localStatePath -Raw | ConvertFrom-Json
        $encryptedKey = $localStateContent.os_crypt.encrypted_key
        
        if (-not $encryptedKey) {
            Write-Host "No encrypted key found in Local State" -ForegroundColor Red
            return $null
        }
        
        Write-Host "Found encrypted master key" -ForegroundColor Green
        
        # Decode from base64
        $encryptedKeyBytes = [System.Convert]::FromBase64String($encryptedKey)
        Write-Host "Encrypted key length: $($encryptedKeyBytes.Length) bytes" -ForegroundColor Yellow
        
        # Remove the DPAPI prefix (first 5 bytes: "DPAPI")
        if ($encryptedKeyBytes.Length -gt 5 -and 
            [System.Text.Encoding]::ASCII.GetString($encryptedKeyBytes, 0, 5) -eq "DPAPI") {
            
            Write-Host "Found DPAPI prefix, extracting master key..." -ForegroundColor Yellow
            $keyToDecrypt = $encryptedKeyBytes[5..($encryptedKeyBytes.Length - 1)]
            
            # Decrypt using DPAPI
            $decryptedKeyString = Get-DecryptedData $keyToDecrypt
            
            if ($decryptedKeyString) {
                Write-Host "Successfully decrypted master key!" -ForegroundColor Green
                $keyBytes = [System.Text.Encoding]::UTF8.GetBytes($decryptedKeyString)
                Write-Host "Master key length: $($keyBytes.Length) bytes" -ForegroundColor Green
                return $keyBytes
            } else {
                Write-Host "Failed to decrypt master key using DPAPI" -ForegroundColor Red
            }
        } else {
            Write-Host "Invalid master key format - no DPAPI prefix found" -ForegroundColor Red
        }
    } catch {
        Write-Host "Error extracting master key: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    return $null
}

# Function to decrypt password data
function Decrypt-PasswordData {
    param(
        [byte[]]$EncryptedData,
        [byte[]]$MasterKey
    )
    
    Write-Host "Attempting to decrypt data of length: $($EncryptedData.Length) bytes" -ForegroundColor Yellow
    
    # First, try to detect encryption method
    if ($EncryptedData.Length -gt 3) {
        $prefix = [System.Text.Encoding]::ASCII.GetString($EncryptedData, 0, 3)
        Write-Host "Data prefix: '$prefix'" -ForegroundColor Yellow
        
        if ($prefix -eq "v10" -or $prefix -eq "v11") {
            Write-Host "Detected modern encryption (v10/v11)" -ForegroundColor Green
            
            if ($MasterKey) {
                Write-Host "Attempting AES-GCM decryption with master key..." -ForegroundColor Yellow
                
                try {
                    # For modern encryption, we need to use the master key with AES-GCM
                    # Extract components from encrypted data
                    # Format: v10/v11 (3 bytes) | nonce (12 bytes) | ciphertext | tag (16 bytes)
                    
                    if ($EncryptedData.Length -lt 15) {
                        Write-Host "Encrypted data too short for AES-GCM" -ForegroundColor Red
                        return "[Data too short]"
                    }
                    
                    $nonce = $EncryptedData[3..14]  # 12-byte nonce
                    $ciphertext = $EncryptedData[15..($EncryptedData.Length - 17)]  # ciphertext
                    $tag = $EncryptedData[($EncryptedData.Length - 16)..($EncryptedData.Length - 1)]  # 16-byte tag
                    
                    Write-Host "Nonce length: $($nonce.Length), Ciphertext length: $($ciphertext.Length), Tag length: $($tag.Length)" -ForegroundColor Yellow
                    
                    # Try to use .NET's built-in AES-GCM if available (.NET 5+)
                    try {
                        Add-Type -AssemblyName System.Security.Cryptography
                        
                        $plaintext = New-Object byte[]($ciphertext.Length)
                        $aesGcm = New-Object System.Security.Cryptography.AesGcm($MasterKey)
                        $aesGcm.Decrypt($nonce, $ciphertext, $tag, $plaintext)
                        
                        $result = [System.Text.Encoding]::UTF8.GetString($plaintext)
                        Write-Host "AES-GCM decryption successful!" -ForegroundColor Green
                        return $result
                    } catch {
                        Write-Host "AES-GCM failed: $($_.Exception.Message)" -ForegroundColor Red
                        return "[AES-GCM failed]"
                    }
                } catch {
                    Write-Host "Modern decryption error: $($_.Exception.Message)" -ForegroundColor Red
                    return "[Modern decryption error]"
                }
            } else {
                Write-Host "No master key available for modern encryption" -ForegroundColor Red
                return "[Master key required]"
            }
        }
    }
    
    # Fallback to DPAPI for legacy encryption
    Write-Host "Trying DPAPI decryption..." -ForegroundColor Yellow
    $result = Get-DecryptedData $EncryptedData
    if ($result) {
        Write-Host "DPAPI decryption successful!" -ForegroundColor Green
        return $result
    }
    
    Write-Host "All decryption methods failed" -ForegroundColor Red
    return "[Decryption failed]"
}

# Function to extract and decrypt passwords from Brave browser
function Get-BravePasswords {
    $braveDataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
    $loginDataPath = Join-Path $braveDataPath "Default\Login Data"
    
    if (-not (Test-Path $loginDataPath)) {
        Write-Host "Brave login database not found at: $loginDataPath" -ForegroundColor Red
        return @()
    }
    
    Write-Host "Found Brave login database" -ForegroundColor Green
    
    # Extract master key
    $masterKey = Get-BraveMasterKey
    
    $results = @()
    
    try {
        # Copy the database to avoid locking issues
        $tempDbPath = "temp_brave.db"
        Copy-Item $loginDataPath $tempDbPath -Force
        
        # Export data using SQLite
        $tempCsvPath = "temp_brave_output.csv"
        
        if (Test-Path ".\sqlite3.exe") {
            $sqlitePath = ".\sqlite3.exe"
        } else {
            $sqlitePath = "sqlite3"
        }
        
        # Query the database - get both hex and blob representations
        $query = @"
SELECT origin_url, username_value, 
       hex(password_value) as password_hex, 
       password_value as password_blob 
FROM logins;
"@
        
        & $sqlitePath -csv -header $tempDbPath $query > $tempCsvPath
        
        if (Test-Path $tempCsvPath) {
            $logins = Import-Csv $tempCsvPath
            Write-Host "Found $($logins.Count) login entries in Brave" -ForegroundColor Green
            
            $counter = 0
            foreach ($login in $logins) {
                $counter++
                Write-Host "Processing entry $counter/$($logins.Count)..." -ForegroundColor Yellow
                
                $decryptedPassword = "[No Data]"
                
                if ($login.password_hex -and $login.password_hex -match "^[0-9A-Fa-f]+$") {
                    try {
                        # Convert hex string to byte array
                        $hexString = $login.password_hex
                        Write-Host "Password data length: $($hexString.Length/2) bytes" -ForegroundColor Gray
                        
                        $passwordBytes = [byte[]]::new($hexString.Length / 2)
                        for ($i = 0; $i -lt $hexString.Length; $i += 2) {
                            $passwordBytes[$i / 2] = [Convert]::ToByte($hexString.Substring($i, 2), 16)
                        }
                        
                        # Decrypt the password
                        $decryptedPassword = Decrypt-PasswordData $passwordBytes $masterKey
                        
                    } catch {
                        $decryptedPassword = "[Error: $($_.Exception.Message)]"
                    }
                }
                
                $results += [PSCustomObject]@{
                    Browser = "Brave"
                    URL = $login.origin_url
                    Username = $login.username_value
                    Password = $decryptedPassword
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                }
                
                # Show progress
                if ($counter % 10 -eq 0) {
                    Write-Host "Processed $counter entries..." -ForegroundColor Cyan
                }
            }
            
            Remove-Item $tempCsvPath -Force -ErrorAction SilentlyContinue
        }
        
        Remove-Item $tempDbPath -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Host "Error processing Brave data: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    return $results
}

# Main execution
Write-Host "Brave Browser Password Extraction Tool" -ForegroundColor Green
Write-Host "======================================" -ForegroundColor Green

# Check if Brave is closed
Write-Host "Please ensure Brave browser is closed before continuing..." -ForegroundColor Yellow
$response = Read-Host "Press Enter to continue or 'X' to exit"
if ($response -eq 'X' -or $response -eq 'x') { exit }

# Install SQLite if needed
if (-not (Test-SQLiteAvailable)) {
    if (-not (Install-SQLiteIfNeeded)) {
        Write-Host "SQLite3 is required. Exiting." -ForegroundColor Red
        exit 1
    }
}

# Get Brave passwords
Write-Host "Starting Brave password extraction..." -ForegroundColor Green
$bravePasswords = Get-BravePasswords

# Display results
if ($bravePasswords.Count -gt 0) {
    Write-Host "`nProcessed $($bravePasswords.Count) passwords from Brave:" -ForegroundColor Green
    
    # Count successfully decrypted passwords
    $successCount = ($bravePasswords | Where-Object { 
        $_.Password -notmatch "\[.*\]" -and $_.Password -ne "[No Data]" 
    }).Count
    
    $successRate = [math]::Round(($successCount / $bravePasswords.Count) * 100, 2)
    
    # Show sample
    $bravePasswords | Select-Object -First 10 | Format-Table -Property URL, Username, Password -AutoSize
    
    # Export to CSV
    try {
        $bravePasswords | Export-Csv -Path $CSVPath -NoTypeInformation -Encoding UTF8 -Force
        Write-Host "`nExported to: $CSVPath" -ForegroundColor Green
        Write-Host "Success rate: $successRate% ($successCount/$($bravePasswords.Count))" -ForegroundColor Cyan
        
    } catch {
        Write-Host "CSV export failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} else {
    Write-Host "No passwords found in Brave." -ForegroundColor Yellow
}

Write-Host "`nBrave password extraction completed." -ForegroundColor Green
