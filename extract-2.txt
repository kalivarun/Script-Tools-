# Brave Browser Password Extraction with v20 Encryption Support
# Specialized for Brave's newer encryption format

param(
    [string]$CSVPath = ".\BravePasswords.csv"
)

Add-Type -AssemblyName System.Security
Add-Type -AssemblyName System.Core

# Function to install SQLite3 if needed
function Install-SQLiteIfNeeded {
    try {
        $sqliteUrl = "https://www.sqlite.org/2023/sqlite-tools-win32-x86-3430200.zip"
        $tempZip = "sqlite-temp.zip"
        
        Invoke-WebRequest -Uri $sqliteUrl -OutFile $tempZip -UseBasicParsing
        Expand-Archive -Path $tempZip -DestinationPath ".\sqlite-temp" -Force
        Copy-Item ".\sqlite-temp\sqlite-tools-win32-x86-3430200\sqlite3.exe" ".\sqlite3.exe" -Force
        
        Remove-Item $tempZip -Force -ErrorAction SilentlyContinue
        Remove-Item ".\sqlite-temp" -Recurse -Force -ErrorAction SilentlyContinue
        
        return $true
    } catch {
        return $false
    }
}

# Function to decrypt data using Windows DPAPI
function Get-DecryptedData {
    param([byte[]]$EncryptedData)
    
    try {
        $decrypted = [System.Security.Cryptography.ProtectedData]::Unprotect(
            $EncryptedData, 
            $null, 
            [System.Security.Cryptography.DataProtectionScope]::CurrentUser
        )
        return [System.Text.Encoding]::UTF8.GetString($decrypted)
    } catch {
        return $null
    }
}

# Function to extract master key from Brave's Local State file
function Get-BraveMasterKey {
    $braveDataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
    $localStatePath = Join-Path $braveDataPath "Local State"
    
    if (-not (Test-Path $localStatePath)) {
        return $null
    }
    
    try {
        $localStateContent = Get-Content $localStatePath -Raw | ConvertFrom-Json
        $encryptedKey = $localStateContent.os_crypt.encrypted_key
        
        if (-not $encryptedKey) {
            return $null
        }
        
        $encryptedKeyBytes = [System.Convert]::FromBase64String($encryptedKey)
        
        if ($encryptedKeyBytes.Length -gt 5) {
            $keyToDecrypt = $encryptedKeyBytes[5..($encryptedKeyBytes.Length - 1)]
            $decryptedKeyString = Get-DecryptedData $keyToDecrypt
            
            if ($decryptedKeyString) {
                return [System.Text.Encoding]::UTF8.GetBytes($decryptedKeyString)
            }
        }
        return $null
    } catch {
        return $null
    }
}

# Special function to handle v20 encryption (Brave-specific)
function Decrypt-v20Password {
    param(
        [byte[]]$EncryptedData,
        [byte[]]$MasterKey
    )
    
    try {
        # v20 encryption structure is different from v10/v11
        # Check if data is long enough
        if ($EncryptedData.Length -lt 20) {
            return "[v20 data too short]"
        }
        
        # Try alternative decryption methods for v20
        # Method 1: Try direct DPAPI as fallback
        $result = Get-DecryptedData $EncryptedData
        if ($result) {
            return $result
        }
        
        # Method 2: Try to use the master key with different parameters
        if ($MasterKey) {
            # This is a speculative approach - may need adjustment
            try {
                # Try to decrypt using the master key with different offset
                if ($EncryptedData.Length -gt 16) {
                    # Skip the v20 prefix and try to decrypt the rest
                    $payload = $EncryptedData[4..($EncryptedData.Length - 1)]
                    $result = Get-DecryptedData $payload
                    if ($result) {
                        return $result
                    }
                }
            } catch {
                # Ignore and try next method
            }
        }
        
        return "[v20 decryption not supported]"
        
    } catch {
        return "[v20 error: $($_.Exception.Message)]"
    }
}

# Main decryption function
function Decrypt-PasswordData {
    param(
        [byte[]]$EncryptedData,
        [byte[]]$MasterKey
    )
    
    if ($EncryptedData.Length -gt 3) {
        $prefix = [System.Text.Encoding]::ASCII.GetString($EncryptedData, 0, 3)
        
        # Handle different encryption versions
        switch ($prefix) {
            "v10" { 
                # Standard AES-GCM encryption
                return "[v10 encryption - requires .NET 5+]"
            }
            "v11" { 
                # Standard AES-GCM encryption
                return "[v11 encryption - requires .NET 5+]"
            }
            "v20" {
                # Brave's newer encryption format
                return Decrypt-v20Password $EncryptedData $MasterKey
            }
            default {
                # Try DPAPI for legacy encryption
                $result = Get-DecryptedData $EncryptedData
                if ($result) {
                    return $result
                }
                return "[Unknown encryption format]"
            }
        }
    }
    
    # Fallback to DPAPI
    $result = Get-DecryptedData $EncryptedData
    if ($result) {
        return $result
    }
    
    return "[Decryption failed]"
}

# Function to extract passwords from Brave
function Get-BravePasswords {
    $braveDataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
    $loginDataPath = Join-Path $braveDataPath "Default\Login Data"
    
    if (-not (Test-Path $loginDataPath)) {
        return @()
    }
    
    $masterKey = Get-BraveMasterKey
    $results = @()
    
    try {
        $tempDbPath = "temp_brave.db"
        Copy-Item $loginDataPath $tempDbPath -Force
        
        $tempCsvPath = "temp_brave_output.csv"
        
        if (Test-Path ".\sqlite3.exe") {
            $sqlitePath = ".\sqlite3.exe"
        } else {
            $sqlitePath = "sqlite3"
        }
        
        $query = "SELECT origin_url, username_value, hex(password_value) as password_hex FROM logins;"
        & $sqlitePath -csv -header $tempDbPath $query > $tempCsvPath
        
        if (Test-Path $tempCsvPath) {
            $logins = Import-Csv $tempCsvPath
            
            foreach ($login in $logins) {
                $decryptedPassword = "[No Data]"
                
                if ($login.password_hex -and $login.password_hex -match "^[0-9A-Fa-f]+$") {
                    try {
                        $hexString = $login.password_hex
                        $passwordBytes = [byte[]]::new($hexString.Length / 2)
                        for ($i = 0; $i -lt $hexString.Length; $i += 2) {
                            $passwordBytes[$i / 2] = [Convert]::ToByte($hexString.Substring($i, 2), 16)
                        }
                        
                        $decryptedPassword = Decrypt-PasswordData $passwordBytes $masterKey
                    } catch {
                        $decryptedPassword = "[Error]"
                    }
                }
                
                $results += [PSCustomObject]@{
                    Browser = "Brave"
                    URL = $login.origin_url
                    Username = $login.username_value
                    Password = $decryptedPassword
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                }
            }
            
            Remove-Item $tempCsvPath -Force -ErrorAction SilentlyContinue
        }
        
        Remove-Item $tempDbPath -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    return $results
}

# Main execution
Write-Host "Brave Password Extraction (v20 Support)" -ForegroundColor Green
Write-Host "=======================================" -ForegroundColor Green

if (-not (Test-Path ".\sqlite3.exe")) {
    if (-not (Install-SQLiteIfNeeded)) {
        Write-Host "SQLite3 download failed. Exiting." -ForegroundColor Red
        exit 1
    }
}

Write-Host "Extracting Brave passwords..." -ForegroundColor Yellow
$bravePasswords = Get-BravePasswords

if ($bravePasswords.Count -gt 0) {
    $successCount = ($bravePasswords | Where-Object { 
        $_.Password -notmatch "\[.*\]" -and $_.Password -ne "[No Data]" 
    }).Count
    
    $bravePasswords | Export-Csv -Path $CSVPath -NoTypeInformation -Encoding UTF8 -Force
    
    Write-Host "`nResults:" -ForegroundColor Green
    Write-Host "Total passwords: $($bravePasswords.Count)" -ForegroundColor Cyan
    Write-Host "Successfully decrypted: $successCount" -ForegroundColor Cyan
    
    $bravePasswords | Select-Object -First 10 | Format-Table -Property URL, Username, Password -AutoSize
    Write-Host "Full results exported to: $CSVPath" -ForegroundColor Green
    
} else {
    Write-Host "No passwords found in Brave." -ForegroundColor Yellow
}
